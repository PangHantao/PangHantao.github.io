[{"title":"混合编程-C#调用Java代码之简单篇","date":"2018-04-07T16:00:00.000Z","path":"2018/04/08/混合编程-WPF调用Java代码之简单篇.html","text":"前言：这几天在处理跨语言调用的时候碰了不少坑，为了让更多的开发者更快速高效地解决问题，写个文章记录一下，和大家分享！ 何为混合编程混合编程指的是使用两种或两种以上的程序设计语言来开发应用程序的过程。 (来自百度百科) 优势：能够结合各种语言之间的优势，来开发一个强劲的系统。比如Java和C++：JAVA简单，开发效率很高，完全面向对象，适合做应用程序，C++复杂，运行效率高，难以反编译，适合做底层。Android应用开发时，用Java写应用层，开发效率高，底层关键算法可考虑使用C++，执行效率高，也不容易被反编译，保密性更好。 缺陷：混合编程带来的缺陷就是人员的调动，需要每个语言都有一个专家级人物，能够对该语言产生的疑难杂症进行快速地判断处理，除了每个语言要有一个专家级人物之外，还有有一个主力，负责统筹各语言之间的交互问题，协调处理语言之间的数据交互等问题。 工具介绍 - IKVM这里我们以C#调用Java为例，C#调用Java代码需要用到一个工具，那就是IKVM，该工具的作用就是将Jar包转换成DLL文件 IKVM介绍： 在.NET中实现的Java虚拟机 Java类库的.NET实现 支持Java和.NET互操作性的工具 官网：https://www.ikvm.net/ 环境配置1.判断是否安装IKVM 测试环境： 按Win+R，然后输入cmd打开命令行，最后在命令行中输入IKVM，如果显示&#39;ikvm&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。，说明未安装，继续第二步 下载工具： 进入官网，找到下载链接，官网的下载链接是IKVM 7的版本，下载链接为：https://sourceforge.net/projects/ikvm/files/ ， 打开如下图所示界面，点击红色方框的按钮进行下载，等待几秒就会自动下载了。 配置环境 下载下来就是配置环境变量了，比如说我解压到了D盘，那么我在添加到系统环境变量的Path下，添加一个路径就是：D:\\ikvm-7.2.4630.5\\bin 环境验证： 在命令窗口中输入IKVM，如果出现下图，说明环境配置成功！如果还是出现如步骤一的图示，说明环境配置不成功！ 实现过程1、创建Java工程 注意事项： 该工程的JRE运行环境是1.7的 需要被调用的方法(即getString())不能被private和static修饰 包名不能是默认的包名(即缺省的包名)，否则在C#中将无法通过命名空间找到该类 工程代码如下： 1234567891011package com.test;public class JarClass &#123; /** * 创建一个公有非静态的方法 * @return */ public String getString() &#123; return &quot;Hello World!&quot;; &#125;&#125; 2、将工程打包成Jar包 在Java项目中点击：右键 -&gt; Export -&gt; Java -&gt; Jar file -&gt; Next ，出现下图所示的画面，图中的3就是选择要导出Jar包的路径，完成之后一路点击Next即可。 完成上面这些步骤之后，会得到一个Jar包。这个Jar包就是用来转换成DLL文件的。 3、将Jar文件转换成DLL文件 命令行中使用IKVM将JAR包转换成DLL文件，转换命令为：ikvmc -out:要转换的dll文件名称 转换Jar包的路径 例如：ikvmc -out:JarTest.dll C:\\Users\\pangh\\Desktop\\JarTest.jar 出现下图说明转换成功，此时在JarTest.jar文件同一路径下，会多出一个JarTest.dll的文件，这个就是要在C#中使用到的文件啦！ 4、新建一个WPF项目 首先要在WPF中通过NuGet包管理器安装IKVM插件。点击：工具 -&gt; NuGet包管理器 -&gt; 管理解决方案的NuGet 包管理器 进入NuGet包管理器之后，点击：浏览 -&gt;输入IKVM -&gt;点击IKVM -&gt;右侧选择当前项目 -&gt;选择IKVM的版本为：7.2.4630.5 -&gt;安装 注意：WPF项目里安装的IKVM的版本要和将Jar转DLL的IKVM版本一致，否则会出现IKVM版本冲突的情况 等待一会，安装完成后控制台会输出 安装完成之后查看WPF项目的引用，会多出一下关于IKVM的DLL文件 5、使用DLL文件 在项目中通过添加引用把我们的DLL文件添加到引用中 添加引用完成之后，在MainWindow.cs 文件中使用该我们的DLL文件，使用方式是通过using Java程序的包名，然后再通过包名找到相应的类，最后在通过类调用相应的方法（这一步很关键） cs文件代码如下: 1234567891011121314151617181920212223using System.Windows;using com.test; // 这一步很关键，只有using com.test才能找到Java项目中的JarClass类namespace WpfApp1&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; JarClass test = new JarClass(); string t = test.getString(); MessageBox.Show(t); &#125; &#125;&#125; 调用成功的图片 关键步骤 1、导出Jar包 2、使用IKVM将Jar包转换成DLL文件 3、在C#中使用DLL文件，调用Java代码 本文小结 通过初次接触混合编程的过程，也踩了不少坑，混合编程给我们带来了多种语言的优势，我们在整合多种语言的时候也需要注意版本问题，如果把混合编程利用的好的话，能够给我们带来很多的便利。下一篇文章将给大家带来C#如何调用Java代码(复杂篇)。 希望能够帮助到更多的developer. 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"Java","slug":"Java","permalink":"http://hunterblog.cn/tags/Java/"},{"name":"WPF","slug":"WPF","permalink":"http://hunterblog.cn/tags/WPF/"},{"name":"C#","slug":"C","permalink":"http://hunterblog.cn/tags/C/"},{"name":"混合编程","slug":"混合编程","permalink":"http://hunterblog.cn/tags/混合编程/"}]},{"title":"算法小结-全排列生成算法之字典序法","date":"2018-03-26T16:00:00.000Z","path":"2018/03/27/算法小结-全排列生成算法之字典序法.html","text":"前言：本篇文章将介绍编程中常用的全排列算法之字典序法，字典序法是全排列生成算法中的一种常见算法 算法定义全排列生成算法： 是将给定的序列中所有可能的全排列无重复无遗漏地枚举出来。此处全排列的定义是：从n个元素中取出m个元素进行排列，当n=m时这个排列被称为全排列。 字典序法： 就是将元素按照字典的顺序（a-z, 1-9）进行排列。以字典的顺序作为比较的依据，可以比较出两个串的大小。比如 “1” &lt; “13”&lt;”14”&lt;”153”， 就是按每个数字位逐个比较的结果。对于一个串“123456789”， 可以知道最小的串是“123456789”，而最大的串“987654321”。这样针对这个串以字典序法生成全排列生成全排列，就是依次生成“123456789”-&gt;“123456798”-&gt;……-&gt;”987654312”-&gt;”987654321”这样的串。字典序法要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。 算法步骤 设一个需要排序的集合为list = {1,2,3}，要求该集合为升序集合 步骤一：从右往左，找出第一个左边小于右边的数，记为list[a], 即list[a] = 2; 步骤二：从右往左，找出第一个大于list[a]的数，记为list[b], 即list[b] = 3; 步骤三：将list[a]和list[b]交换位置 步骤四：将list[a]后面的数据(不包括list[a])由小到大排列。重复步骤一，直到执行次数达到该集合的大小的阶乘时，算法结束，输出结果。 算法例子 设现有一个集合为 list={1,2,3} , 则它的全排列输出为：123,132,213,231,312,321。 算法实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class main &#123; /** * 传入全排列数组，进行交换位置 * @param list * @param a * @param b */ public static void swap(int[] list, int a, int b) &#123; int temp = list[a]; list[a] = list[b]; list[b] = temp; &#125; /** * 将list区间[a,n]之间的数据由小到大进行排序 * @param list * @param a * @param n */ public static void sort(int[] list, int a) &#123; int temp = 0; int n = list.length; for(int i = 1; i &lt; n-a; i++) &#123; for(int j = a+1; j &lt; n-1; j++) &#123; if (list[j] &gt; list[j+1]) &#123; temp = list[j]; list[j] = list[j+1]; list[j+1] = temp; &#125; &#125; &#125; &#125; public static void prim(int[] list) &#123; int num = 1, a = 0, b = 0; // 计算算法需要执行的次数，执行的次数等于集合大小的阶乘 for(int i = list.length; i &gt; 0; --i) &#123; num *= i; &#125; while (num-- != 0) &#123; for(int i = 0; i &lt; list.length; i++) &#123; System.out.print(list[i] + \" \"); &#125; System.out.println(); // 从右到左，找到第一个左边比右边小的数，设为list[a] for(int i = list.length - 1; i &gt; 0; i--) &#123; if (list[i-1] &lt; list[i]) &#123; a = i-1; break; &#125; &#125; // 从右到左，找到第一个比list[a]大的数，设为list[b] for(int i = list.length - 1; i &gt; a; i--) &#123; if (list[i] &gt; list[a]) &#123; b = i; break; &#125; &#125; // 将list[a]和list[b]交换 swap(list, a, b); // 对list[a]之后的数据进行排序 sort(list, a); &#125; &#125; public static void main(String[] args) &#123; int[] list = &#123;1,2,3&#125;; prim(list); &#125;&#125; 输出结果为： 1 2 31 3 22 1 32 3 13 1 23 2 1 算法细节 该算法对数据的要求是升序的，否则会出现结果重复的问题 该算法能够对重复的数据进行全排列，比如说集合{1,2,3,3} 算法小结 该算法是全排列算法中的一种常见的方式，上面已经对算法的一些细节问题进行提及，也许这个算法的实现不是最优的方式，如有其它实现方式，可以共同交流~ 晚安 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"算法","slug":"Algorithm","permalink":"http://hunterblog.cn/tags/Algorithm/"}]},{"title":"Andrind之Animation详解","date":"2017-10-24T08:53:47.000Z","path":"2017/10/24/Andrind之Animation详解.html","text":"前言：在Android开发中，动画效果是经常用到的，比如说在启动页面时的动态展示LOGO，这篇文章主要讲解四大补间动画。 Animation的四种类型 TranslateAnimation 实现位置移动的动画效果 AlphaAnimation 实现渐变透明度的动画效果 ScaleAnimation 实现图形缩的放动画效果 RoateAnimation 实现旋转的动画效果 下面来看一下总体的效果图： 注：实现这中动画效果有两种方式，一种是用过配置xml配置文件实现，另外一种是直接通过编写Java代码实现，本篇文章我们主要介绍第二种方式(Java代码)实现 Activity的xml文件如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:layout_centerInParent=\"true\" android:id=\"@+id/iv\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;LinearLayout android:weightSum=\"4\" android:gravity=\"bottom\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_tran\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"平移\" /&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_alpha\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"透明\" /&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_roate\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"旋转\" /&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_scale\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"缩放\" /&gt; &lt;Button android:layout_weight=\"1\" android:text=\"组合\" android:id=\"@+id/btn_set\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 四大种类的属性通用属性setRepeatCount(int repeatCount) 设置动画的重复次数，当repeatCount等于-1时，标识无限循环 setDuration(long durationMillis) 设置动画的播放时长setRepeatMode(int repeatMode) 设置动画的重复方式，Animation.REVERSR：反向Animation.RESTART：重新开始（默认） setFillAfter(boolean fillAfter) 动画执行完后是否停留在执行完的状态true：停留在执行完的状态false：停留在动画开始前的状态 1.TranslateAnimation 平移动画创建TranslateAnimation对象TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) 参数说明： float fromXDelta 动画开始的点离当前View X坐标上的差值 float toXDelta 动画结束的点离当前View X坐标上的差值 float fromYDelta 动画开始的点离当前View Y坐标上的差值 float toYDelta 动画开始的点离当前View Y坐标上的差值 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class AnimationActivity extends AppCompatActivity &#123; private ImageView iv; private Button btn_tran, btn_alpha, btn_rotate, btn_scale, btn_set; private static Animation animation; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animation); iv = (ImageView) findViewById(R.id.iv); btn_tran = (Button) findViewById(R.id.btn_tran); btn_alpha = (Button) findViewById(R.id.btn_alpha); btn_rotate = (Button) findViewById(R.id.btn_roate); btn_scale = (Button) findViewById(R.id.btn_scale); btn_set = (Button) findViewById(R.id.btn_set); btn_tran.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) 参数说明： float fromXDelta 动画开始的点离当前View X坐标上的差值 float toXDelta 动画结束的点离当前View X坐标上的差值 float fromYDelta 动画开始的点离当前View Y坐标上的差值 float toYDelta 动画开始的点离当前View Y坐标上的差值 */ animation = new TranslateAnimation(0.5f, 200f, 0.5f, 0.5f); //该动画重复次数 -1代表无限循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(500); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.REVERSE); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125;&#125; 2.AlphaAnimation 渐变透明度动画创建TranslateAnimation对象AlphaAnimation(float fromAlpha, float toAlpha) 参数说明： float fromAlpha 动画开始时的透明度 透明度范围：0表示全透明 1标识完全不透明 float toAlpha 动画结束时的透明度 12345678910111213141516171819202122232425262728293031323334353637383940414243public class AnimationActivity extends AppCompatActivity &#123; private ImageView iv; private Button btn_tran, btn_alpha, btn_rotate, btn_scale, btn_set; private static Animation animation; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animation); iv = (ImageView) findViewById(R.id.iv); btn_tran = (Button) findViewById(R.id.btn_tran); btn_alpha = (Button) findViewById(R.id.btn_alpha); btn_rotate = (Button) findViewById(R.id.btn_roate); btn_scale = (Button) findViewById(R.id.btn_scale); btn_set = (Button) findViewById(R.id.btn_set); btn_alpha.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* AlphaAnimation(float fromAlpha, float toAlpha) 参数说明: float fromAlpha 动画开始时的透明度 透明度范围：0表示全透明 1标识完全不透明 float toAlpha 动画结束时的透明度 */ animation = new AlphaAnimation(0.2f, 1.0f); //该动画重复次数 -1代表无线循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(200); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.REVERSE); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125;&#125; 3.TranslateAnimation 旋转动画效果创建TranslateAnimation对象TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) 参数说明： float fromXDelta 动画开始的点离当前View X坐标上的差值 float toXDelta 动画结束的点离当前View X坐标上的差值 float fromYDelta 动画开始的点离当前View Y坐标上的差值 float toYDelta 动画开始的点离当前View Y坐标上的差值 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class AnimationActivity extends AppCompatActivity &#123; private ImageView iv; private Button btn_tran, btn_alpha, btn_rotate, btn_scale, btn_set; private static Animation animation; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animation); iv = (ImageView) findViewById(R.id.iv); btn_tran = (Button) findViewById(R.id.btn_tran); btn_alpha = (Button) findViewById(R.id.btn_alpha); btn_rotate = (Button) findViewById(R.id.btn_roate); btn_scale = (Button) findViewById(R.id.btn_scale); btn_set = (Button) findViewById(R.id.btn_set); btn_tran.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) 参数说明： float fromXDelta 动画开始的点离当前View X坐标上的差值 float toXDelta 动画结束的点离当前View X坐标上的差值 float fromYDelta 动画开始的点离当前View Y坐标上的差值 float toYDelta 动画开始的点离当前View Y坐标上的差值 */ animation = new TranslateAnimation(0.5f, 200f, 0.5f, 0.5f); //该动画重复次数 -1代表无限循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(500); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.REVERSE); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125;&#125; 4.ScaleAnimation 缩放的动画效果创建ScaleAnimation对象ScaleAnimation(float fromX, float toX, float fromY, float toY,int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 参数说明： float fromX 动画起始时 X坐标上的伸缩尺寸 float toX 动画结束时 X坐标上的伸缩尺寸 float fromY 动画起始时Y坐标上的伸缩尺寸 float toY 动画结束时Y坐标上的伸缩尺寸 int pivotXType 动画在X轴相对于物件位置类型 float pivotXValue 动画相对于物件的X坐标的开始位置 int pivotYType 动画在Y轴相对于物件位置类型 float pivotYValue 动画相对于物件的Y坐标的开始位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class AnimationActivity extends AppCompatActivity &#123; private ImageView iv; private Button btn_tran, btn_alpha, btn_rotate, btn_scale, btn_set; private static Animation animation; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animation); iv = (ImageView) findViewById(R.id.iv); btn_tran = (Button) findViewById(R.id.btn_tran); btn_alpha = (Button) findViewById(R.id.btn_alpha); btn_rotate = (Button) findViewById(R.id.btn_roate); btn_scale = (Button) findViewById(R.id.btn_scale); btn_set = (Button) findViewById(R.id.btn_set); btn_scale.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* ScaleAnimation(float fromX, float toX, float fromY, float toY,int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 参数说明： float fromX 动画起始时 X坐标上的伸缩尺寸 float toX 动画结束时 X坐标上的伸缩尺寸 float fromY 动画起始时Y坐标上的伸缩尺寸 float toY 动画结束时Y坐标上的伸缩尺寸 int pivotXType 动画在X轴相对于物件位置类型 float pivotXValue 动画相对于物件的X坐标的开始位置 int pivotYType 动画在Y轴相对于物件位置类型 float pivotYValue 动画相对于物件的Y坐标的开始位置 */ //创建一个缩放动画 X轴：0.5f -&gt; 2.0f Y轴：0.5f -&gt; 2.0f animation = new ScaleAnimation(0.5f, 2.0f, 0.5f, 2.0f); //该动画重复次数 -1代表无线循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(500); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.REVERSE); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class AnimationActivity extends AppCompatActivity &#123; private ImageView iv; private Button btn_tran, btn_alpha, btn_rotate, btn_scale, btn_set; private static Animation animation; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animation); iv = (ImageView) findViewById(R.id.iv); btn_tran = (Button) findViewById(R.id.btn_tran); btn_alpha = (Button) findViewById(R.id.btn_alpha); btn_rotate = (Button) findViewById(R.id.btn_roate); btn_scale = (Button) findViewById(R.id.btn_scale); btn_set = (Button) findViewById(R.id.btn_set); btn_set.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AnimationSet animationSet = new AnimationSet(true); TranslateAnimation tranAnimation = new TranslateAnimation(0.5f, 100f, 0.5f, 100f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.2f, 1.0f); ScaleAnimation scaleAnimation = new ScaleAnimation(0.5f, 2.0f, 0.5f, 2.0f, 0.5f, 0.5f); tranAnimation.setRepeatCount(-1); alphaAnimation.setRepeatCount(-1); scaleAnimation.setRepeatCount(-1); animationSet.addAnimation(tranAnimation); animationSet.addAnimation(alphaAnimation); animationSet.addAnimation(scaleAnimation); animationSet.setRepeatMode(Animation.REVERSE); animationSet.setDuration(500); animationSet.setFillAfter(true); iv.startAnimation(animationSet); &#125; &#125;); &#125;｝ AnimationSet 动画集当你在实现单个补间动画的时候，往往不能满足需求，这是就需要用到动画集AnimationSet,顾名思义，AnimationSet代表的就是将多个补间动画集中到一个集合中，下面我们来看下如何去实现这样的一种效果 AnimationSet的原理就是在同一时间触发多个补间动画。首先创建多种单个补间动画，然后添加到animationSet集合中，再经过一些列的属性设置，最终通过startAnimation(Animation animation)方法启动即可。有个注意点就是：==如果直接通过设置animationSet.setRepeatCount(-1)的话，动画依然还是执行一次，为了解决这个问题，可以先对每一个补间动画设置RepeatCount为-1，再将各个动画添加到动画集中！ #FF0009== 写在最后以上为对Android Animation学习之后的一点见解，当然如果你愿意了解学习更多的话，也可以通过自己的拓展进行学习和开发！现将java文件和xml文件完整版贴出来供大家分享，如有不当的地方，欢迎指正与讨论！ java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195package animation.demo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.animation.AlphaAnimation;import android.view.animation.Animation;import android.view.animation.AnimationSet;import android.view.animation.RotateAnimation;import android.view.animation.ScaleAnimation;import android.view.animation.TranslateAnimation;import android.widget.Button;import android.widget.ImageView;import com.demo.weather.R;public class AnimationActivity extends AppCompatActivity &#123; private ImageView iv; private Button btn_tran, btn_alpha, btn_rotate, btn_scale, btn_set; private static Animation animation; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_animation); findViewById(); initView(); &#125; private void initView() &#123; tranAnimation(); alphaAnimation(); rotateAnimation(); scaleAnimation(); setAnimation(); &#125; //组合动画 private void setAnimation() &#123; btn_set.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AnimationSet animationSet = new AnimationSet(true); TranslateAnimation tranAnimation = new TranslateAnimation(0.5f, 100f, 0.5f, 100f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.2f, 1.0f); ScaleAnimation scaleAnimation = new ScaleAnimation(0.5f, 2.0f, 0.5f, 2.0f, 0.5f, 0.5f); tranAnimation.setRepeatCount(-1); alphaAnimation.setRepeatCount(-1); scaleAnimation.setRepeatCount(-1); animationSet.addAnimation(tranAnimation); animationSet.addAnimation(alphaAnimation); animationSet.addAnimation(scaleAnimation); animationSet.setRepeatMode(Animation.REVERSE); animationSet.setDuration(500); animationSet.setFillAfter(true); iv.startAnimation(animationSet); &#125; &#125;); &#125; //缩放动画 private void scaleAnimation() &#123; btn_scale.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* ScaleAnimation(float fromX, float toX, float fromY, float toY,int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 参数说明： float fromX 动画起始时 X坐标上的伸缩尺寸 float toX 动画结束时 X坐标上的伸缩尺寸 float fromY 动画起始时Y坐标上的伸缩尺寸 float toY 动画结束时Y坐标上的伸缩尺寸 int pivotXType 动画在X轴相对于物件位置类型 float pivotXValue 动画相对于物件的X坐标的开始位置 int pivotYType 动画在Y轴相对于物件位置类型 float pivotYValue 动画相对于物件的Y坐标的开始位置 */ //创建一个缩放动画 X轴：0.5f -&gt; 2.0f Y轴：0.5f -&gt; 2.0f animation = new ScaleAnimation(0.5f, 2.0f, 0.5f, 2.0f); //该动画重复次数 -1代表无线循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(500); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.REVERSE); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125; //旋转动画 private void rotateAnimation() &#123; btn_rotate.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* RotateAnimation (float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 参数说明： float fromDegrees 旋转的开始角度。 float toDegrees 旋转的结束角度。 int pivotXType X轴的伸缩模式，可以取值为ABSOLUTE、RELATIVE_TO_SELF、RELATIVE_TO_PARENT。 float pivotXValue X坐标的伸缩值。 int pivotYType Y轴的伸缩模式，可以取值为ABSOLUTE、RELATIVE_TO_SELF、RELATIVE_TO_PARENT。 float pivotYValue Y坐标的伸缩值。 */ animation = new RotateAnimation(0.0f, 360f, 0.5f, 0.5f); //该动画重复次数 -1代表无线循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(500); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.RESTART); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125; //透明度动画 private void alphaAnimation() &#123; btn_alpha.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* AlphaAnimation(float fromAlpha, float toAlpha) 参数说明: float fromAlpha 动画开始时的透明度 透明度范围：0表示全透明 1标识完全不透明 float toAlpha 动画结束时的透明度 */ animation = new AlphaAnimation(0.2f, 1.0f); //该动画重复次数 -1代表无线循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(200); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.REVERSE); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125; //平移动画 private void tranAnimation() &#123; btn_tran.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /* TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) 参数说明： float fromXDelta 动画开始的点离当前View X坐标上的差值 float toXDelta 动画结束的点离当前View X坐标上的差值 float fromYDelta 动画开始的点离当前View Y坐标上的差值 float toYDelta 动画开始的点离当前View Y坐标上的差值 */ animation = new TranslateAnimation(0.5f, 200f, 0.5f, 0.5f); //该动画重复次数 -1代表无限循环 animation.setRepeatCount(-1); //设置动画的播放时长 单位为毫秒 animation.setDuration(500); //设置动画重复方式 Animation.REVERSR：反向 Animation.RESTART：重新开始 animation.setRepeatMode(Animation.REVERSE); ////动画执行完后是否停留在执行完的状态 animation.setFillAfter(true); //为图片添加动画,并开始动画 iv.startAnimation(animation); &#125; &#125;); &#125; private void findViewById() &#123; iv = (ImageView) findViewById(R.id.iv); btn_tran = (Button) findViewById(R.id.btn_tran); btn_alpha = (Button) findViewById(R.id.btn_alpha); btn_rotate = (Button) findViewById(R.id.btn_roate); btn_scale = (Button) findViewById(R.id.btn_scale); btn_set = (Button) findViewById(R.id.btn_set); &#125;&#125; xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:layout_centerInParent=\"true\" android:id=\"@+id/iv\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;LinearLayout android:weightSum=\"4\" android:gravity=\"bottom\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_tran\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"平移\" /&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_alpha\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"透明\" /&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_roate\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"旋转\" /&gt; &lt;Button android:layout_weight=\"1\" android:id=\"@+id/btn_scale\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"缩放\" /&gt; &lt;Button android:layout_weight=\"1\" android:text=\"组合\" android:id=\"@+id/btn_set\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"Android","slug":"Android","permalink":"http://hunterblog.cn/tags/Android/"}]},{"title":"WPF实现仿网易云唱片图标","date":"2017-09-24T08:53:47.000Z","path":"2017/09/24/WPF_Record.html","text":"相信大家对于网易云音乐并不陌生，仔细发现，每当我们点击播放和暂停音乐的时候，歌词左侧的唱片控件都会发生一些小变化。在人们的视野中，动态的物体总是那么引人注意，下面我将来说下如何用WPF实现这一效果，与大家共同分享 前期思考 实现该效果可分为两个步骤： 实现唱片的旋转 实现指针的旋转 刚开始分析的时候，我是用Button来控制唱片的转动和暂停的，但是后来发现Button的点击事件只能控制一种状态（既只能控制转动或者暂停），后来经过网上查阅了之后发现可以使用ToggleButton替换Button ToggleButton也称为状态按钮，可以用过一个按钮切换多种状态（比如灯的ON/OFF） 该控件有一个IsChecked属性，IsChecked的值有三种,分别是True,False,Null。ToggleButton的事件如下： Checked：当IsChecked为True时，触发此事件 UnChecked：当IsChecked为False时，触发此事件 Indeterminate：当IsChecked为Null时，触发此事件 先来看一下最终的效果吧(由于没弄成gif动态图，只能上个图片了)！！！ 唱片旋转唱片旋转是通过Storyboard(故事板)实现XAML代码如下：12345678910111213141516171819202122232425262728293031323334&lt;Window x:Class=\"黑胶唱片旋转.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:local=\"clr-namespace:黑胶唱片旋转\" Background=\"#CCC\" mc:Ignorable=\"d\" Title=\"MainWindow\" Height=\"600\" Width=\"800\"&gt; &lt;Grid&gt; &lt;Image x:Name=\"黑胶唱片\" Width=\"200\" Height=\"200\" Source=\"Resources/Images/黑胶唱片外层.png\" &gt; &lt;Image.RenderTransform&gt; &lt;RotateTransform x:Name=\"recordTs\" Angle=\"0\"&gt;&lt;/RotateTransform&gt; &lt;/Image.RenderTransform&gt; &lt;/Image&gt; &lt;ToggleButton x:Name=\"playMusic\" Content=\"播放\" Margin=\"321,423,321,90\" RenderTransformOrigin=\"0.575,1.538\" Click=\"playMusic_Click\"&gt; &lt;ToggleButton.Triggers&gt; &lt;EventTrigger RoutedEvent=\"ToggleButton.Checked\"&gt; &lt;BeginStoryboard x:Name=\"beginRecord\"&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Storyboard.TargetName=\"recordTs\" Storyboard.TargetProperty=\"Angle\" By=\"360\" RepeatBehavior=\"Forever\" Duration=\"0:0:10\"&gt;&lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;EventTrigger RoutedEvent=\"ToggleButton.Unchecked\"&gt; &lt;PauseStoryboard BeginStoryboardName=\"beginRecord\"&gt;&lt;/PauseStoryboard&gt; &lt;/EventTrigger&gt; &lt;/ToggleButton.Triggers&gt; &lt;/ToggleButton&gt; &lt;/Grid&gt;&lt;/Window&gt; 通过此代码可以通过一个ToggleButton按钮控制图片的旋转和暂停，但是你会发现有一个问题就是：图片默认是沿着左上角为中心点旋转的，而不是沿着图片的中心旋转的。 那么该如何解决这个问题呢？我有个思路：由于我们可以通过获取图片的左上角旋转点的位置，设左上角旋转点的坐标为(centerX,centerY)，这样我们再获取图片的宽(width)和高(height)，通过(centerX + width/2)获得图片的中心点横坐标CenterX，通过(centerY + height/2)获得图片的中心点纵坐标CenterY，(CenterX, CenterY)既为图片在平面上的中心点了。代码实现如下：1234567891011121314/// &lt;summary&gt;/// 设置唱片的旋转中心点/// &lt;/summary&gt;public void SetCenterPoint()&#123; double width = 黑胶唱片.Width; double height = 黑胶唱片.Height; double centerX = recordTs.CenterX + (width / 2); double centerY = recordTs.CenterY + (height / 2); recordTs.CenterX = centerX; recordTs.CenterY = centerY;&#125; 指针旋转通过上面这个步骤，唱片旋转已经实现，现在还缺少一根指针。该指针会随着ToggleButton的不同状态处于不同的位置(当ToggleButton处于播放状态时，该指针会与唱片接触，当ToggleButton处于暂停状态时，该指针会与唱片分离)，实现这个效果的思想还是和实现唱片旋转类似，下面附上XAML的代码：123456789101112131415161718192021222324252627282930313233343536&lt;Window x:Class=\"黑胶唱片旋转.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:local=\"clr-namespace:黑胶唱片旋转\" Background=\"#CCC\" mc:Ignorable=\"d\" Title=\"MainWindow\" Height=\"600\" Width=\"800\"&gt; &lt;Grid&gt; &lt;Image x:Name=\"指针唱片\" Source=\"Resources/Images/唱片指针.png\" Width=\"200\" Margin=\"296,116,296,333\" &gt; &lt;Image.RenderTransform&gt; &lt;RotateTransform x:Name=\"pointerTs\" Angle=\"0\"/&gt; &lt;/Image.RenderTransform&gt; &lt;/Image&gt; &lt;ToggleButton x:Name=\"playMusic\" Content=\"播放\" Margin=\"321,423,321,90\" RenderTransformOrigin=\"0.575,1.538\" Click=\"playMusic_Click\"&gt; &lt;ToggleButton.Triggers&gt; &lt;EventTrigger RoutedEvent=\"ToggleButton.Checked\"&gt; &lt;BeginStoryboard x:Name=\"beginPointer\"&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Storyboard.TargetName=\"pointerTs\" Storyboard.TargetProperty=\"Angle\" To=\"10\" Duration=\"0:0:1\"/&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;EventTrigger RoutedEvent=\"ToggleButton.Unchecked\"&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Storyboard.TargetName=\"pointerTs\" Storyboard.TargetProperty=\"Angle\" To=\"0\" Duration=\"0:0:1\"/&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;/ToggleButton.Triggers&gt; &lt;/ToggleButton&gt; &lt;/Grid&gt;&lt;/Window&gt; 整合唱片和指针上面的两个步骤已经实现通过按钮实现按钮和指针的旋转了，现在对两者进行整合，附上完整代码如下： XAML 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;Window x:Class=\"黑胶唱片旋转.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:local=\"clr-namespace:黑胶唱片旋转\" Background=\"#CCC\" mc:Ignorable=\"d\" Title=\"MainWindow\" Height=\"600\" Width=\"800\"&gt; &lt;Grid&gt; &lt;Image x:Name=\"黑胶唱片\" Width=\"200\" Height=\"200\" Source=\"Resources/Images/黑胶唱片外层.png\" &gt; &lt;Image.RenderTransform&gt; &lt;RotateTransform x:Name=\"recordTs\" Angle=\"0\"&gt;&lt;/RotateTransform&gt; &lt;/Image.RenderTransform&gt; &lt;/Image&gt; &lt;Image x:Name=\"指针唱片\" Source=\"Resources/Images/唱片指针.png\" Width=\"200\" Margin=\"296,116,296,333\" &gt; &lt;Image.RenderTransform&gt; &lt;RotateTransform x:Name=\"pointerTs\" Angle=\"0\"/&gt; &lt;/Image.RenderTransform&gt; &lt;/Image&gt; &lt;ToggleButton x:Name=\"playMusic\" Content=\"播放\" Margin=\"321,423,321,90\" RenderTransformOrigin=\"0.575,1.538\" Click=\"playMusic_Click\"&gt; &lt;ToggleButton.Triggers&gt; &lt;EventTrigger RoutedEvent=\"ToggleButton.Checked\"&gt; &lt;BeginStoryboard x:Name=\"beginRecord\"&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Storyboard.TargetName=\"recordTs\" Storyboard.TargetProperty=\"Angle\" By=\"360\" RepeatBehavior=\"Forever\" Duration=\"0:0:10\"&gt;&lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;BeginStoryboard x:Name=\"beginPointer\"&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Storyboard.TargetName=\"pointerTs\" Storyboard.TargetProperty=\"Angle\" To=\"10\" Duration=\"0:0:1\"/&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;EventTrigger RoutedEvent=\"ToggleButton.Unchecked\"&gt; &lt;PauseStoryboard BeginStoryboardName=\"beginRecord\"&gt;&lt;/PauseStoryboard&gt; &lt;BeginStoryboard&gt; &lt;Storyboard&gt; &lt;DoubleAnimation Storyboard.TargetName=\"pointerTs\" Storyboard.TargetProperty=\"Angle\" To=\"0\" Duration=\"0:0:1\"/&gt; &lt;/Storyboard&gt; &lt;/BeginStoryboard&gt; &lt;/EventTrigger&gt; &lt;/ToggleButton.Triggers&gt; &lt;/ToggleButton&gt; &lt;/Grid&gt;&lt;/Window&gt; cs代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Windows;namespace 黑胶唱片旋转&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; private static Boolean isPlay = false; public MainWindow() &#123; InitializeComponent(); SetCenterPoint(); &#125; /// &lt;summary&gt; /// 设置唱片的旋转中心点 /// &lt;/summary&gt; public void SetCenterPoint() &#123; double width = 黑胶唱片.Width; double height = 黑胶唱片.Height; double centerX = recordTs.CenterX + (width / 2); double centerY = recordTs.CenterY + (height / 2); recordTs.CenterX = centerX; recordTs.CenterY = centerY; &#125; /// &lt;summary&gt; /// 根据按钮状态的改变修改按钮的文字 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"e\"&gt;&lt;/param&gt; private void playMusic_Click(object sender, RoutedEventArgs e) &#123; isPlay = !isPlay; if (playMusic.IsChecked == true) &#123; playMusic.Content = \"暂停\"; &#125;else if(playMusic.IsChecked == false) &#123; playMusic.Content = \"播放\"; &#125; &#125; &#125;&#125; 初识WPF，如果你有更好的想法，可以与我共同分享， 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"WPF","slug":"WPF","permalink":"http://hunterblog.cn/tags/WPF/"}]},{"title":"(转)电话号码分身(小米2017 秋招真题)","date":"2017-09-22T15:36:47.000Z","path":"2017/09/22/Z_Algorithm_phoneNumType.html","text":"原文出处： [算法] 电话号码分身 （小米2017 秋招真题）[JavaScript] ，作者：krun​题目描述 继MIUI8推出手机分身功能，MIUI计划推出一个电话号码分身得功能：首先将电话号码中的每个数字加上8取个位，然后使用对应得大写字母代替 (“ZERO”, “ONE”, “TWO”, “THREE”, “FOUR”, “FIVE”, “SIX”, “SEVEN”, “EIGHT”, “NINE”), 然后随机打乱这些字母，所生成得字符串即为电话号码对应得分身。​例子:输入 =&gt; 输出EIGHT =&gt; 0ZEROTWOONE =&gt; 234OHWETENRTEO =&gt; 345OHEWTIEGTHENRTEO =&gt; 0345​​这道题是输入一个字符串，映射到一个数字串。映射题我的习惯是先尝试用字典的方式做，那么接下来开始做这道题： 10个数字与其英文单词一一对应，那么这些词能不能做些文章呢？ 我们可以发现，在这十个数字的英文单词中，字符 Z 只存在于 ZERO，W 只存在于 TWO，以此类推。所以现在一旦在字符串中发现 Z，我们就可以说存在 0。我们在这里把 Z 称作 特征字符, ZERO 称作 字符值, 0 称为 数字值那么，我们可以得到一组映射: 12345678&#123; Z: ['ZERO', 0], W: ['TWO', 2], U: ['FOUR', 4], X: ['SIX', 6], G: ['EIGHT', 8]&#125; 因此0, 2, 4, 6, 8已经处理好了，现在还剩下 1, 3, 5, 7, 9。仔细分析可以发现，字符O在这五个数字的英文中，只存在于ONE；字符F只存在于FIVE中，以此类推。那么，我们又可以得到一组映射： 1234567&#123; O: ['ONE', 1], T: ['THREE', 3], F: ['FIVE', 5], S: ['SEVEN', 7]&#125; 为什么这里没有9的映射呢？因为 NINE中N, I, E在 1, 3, 5, 7中都有出现，这里我们就先空着。 注意这里的两个映射关系是不可以合并的，想想为什么？ 那么这些映射关系有什么用呢？这里就要用到字典(dict)啦。我们可以把输入的字符串，转换为一个字典结构，key 是字符, value 是这个字符在整个字符串中出现的次数。 例如：12345678910111213\"OHEWTIEGTHENRTEO\"var dict = &#123; E: 4, T: 3, O: 2, H: 2, I: 1, G: 1, W: 1, N: 1, R: 1&#125; 然后我们遍历这个字典:12345678910111213141516171819202122232425262728293031323334[&#123; Z: ['ZERO', 0], W: ['TWO', 2], U: ['FOUR', 4], X: ['SIX', 6], G: ['EIGHT', 8]&#125;,&#123; O: ['ONE', 1], T: ['THREE', 3], F: ['FIVE', 5], S: ['SEVEN', 7]&#125;].map(map =&gt; &#123; Object.keys(dict).map(key =&gt; &#123; /** 检查当前字符是否在映射表中 * 在的话检查字典中当前字符的数量是否仍然大于0 */ map[key] &amp;&amp; dict[key] &gt; 0 &amp;&amp; /** * 把映射关系中的字面值取出并拆解为一个字符数组， * 遍历这个字符数组，将字典中该字符的计数减去1，即消化了这个字面值 */ map[key][0].split('').map(char =&gt; dict[char] -= 1) &amp;&amp; // 把消化的数字值打出来 console.log(map[key][1]) &#125;)&#125;)/** * 2 * 8 * 1 * 3 */ 可是题目说明 OHEWTIEGTHENRTEO 的输出值应该是 0345呀，哪里出错了呢? 注意题目中的一句话 首先将电话号码中的每个数字加上8取个位也就是说，我们打出来的值还需要对这个 加8取个位 进行逆向。有几种方法，一是在打印时对 map[key][1] 进行处理:1num =&gt; num - 8 &gt;= 0 ? num - 8 : num + 2 或者，我这里用了偷懒的办法，还记得我们映射表中有个数字值吗？我人工替换了 ：P1234567891011121314151617181920212223242526[&#123; Z: ['ZERO', 2], W: ['TWO', 4], U: ['FOUR', 6], X: ['SIX', 8], G: ['EIGHT', 0]&#125;,&#123; O: ['ONE', 3], T: ['THREE', 5], F: ['FIVE', 7], S: ['SEVEN', 9&#125;].map(map =&gt; &#123; Object.keys(dict).map(key =&gt; &#123; map[key] &amp;&amp; dict[key] &gt; 0 &amp;&amp; map[key][0].split('').map(char =&gt; dict[char] -= 1) &amp;&amp; console.log(map[key][1]) &#125;)&#125;)/** * 4 * 0 * 3 * 5 */ 那么现在只需要把输出值进行一下正序排序即可：1234567891011121314151617181920212223242526272829var output = [];[&#123; Z: ['ZERO', 2], W: ['TWO', 4], U: ['FOUR', 6], X: ['SIX', 8], G: ['EIGHT', 0]&#125;,&#123; O: ['ONE', 3], T: ['THREE', 5], F: ['FIVE', 7], S: ['SEVEN', 9&#125;].map(map =&gt; &#123; Object.keys(dict).map(key =&gt; &#123; map[key] &amp;&amp; dict[key] &gt; 0 &amp;&amp; map[key][0].split('').map(char =&gt; dict[char] -= 1) &amp;&amp; output.push(map[key][1]) &#125;)&#125;)/* * 还记得我们把 9 的处理留空了吗？现在要补上啦~ * 9 的英文 NINE 你只需要随意检查前边过滤后的字典是否还存在 N I E 任意一个字符即可 * 我选择的是判断 E * 输入的9对应的输出应该是1，还记得为什么吗？ *///if (dict['E'] &amp;&amp; dict['E'] &gt; 0) output.push(1)/** * 2017.09.19 08:36 更新： * 之前只判断了是否还存在9，但是忘了多个9同时存在的情况，那么需要做如下改进： */ dist['E'] &amp;&amp; // 检查是否还存在特征字符 E，在经过前面的映射关系过滤后，还剩下几个E，就还有几个9 (output = output.concat(Array(dist['E']).fill(1))) //纯js技巧，快速生成指定大小的数组并填充一个值output.sort()console.log(output) // 0 3 4 5 虽然说本文标题有个 [算法] 前缀，不过这个写法完全没考虑什么复杂度之类的东西 ORZ","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hunterblog.cn/tags/JavaScript/"},{"name":"算法","slug":"Algorithm","permalink":"http://hunterblog.cn/tags/Algorithm/"}]},{"title":"(转)做个数据库帮助库雏形(一)","date":"2017-09-22T15:36:47.000Z","path":"2017/09/22/Z_MySQLForHelpL01.html","text":"原文出处： [JAVA][学习·练手·挖坑] 做个数据库帮助库雏形 ，作者：krun 在以往的编码中，使用过 spring-data-jpa，也用过 hibernate 和 mybatis。在简单的数据库操作中，spring-data-jpa 是用起来最爽的，毕竟在 IntelliJ IDEA 中可以获得如下体验： 瞧瞧，实体类属性推导，查询条件推导。声明完接口就可以用了，一行sql都不用敲，多爽 在这里就不讨论这三个框架的优劣了，毕竟就我目前的使用场景而言，也体会不太出来到底谁好用…毕竟复杂的 SQL查询都是要 类似hql或者XML 的解决方案来做的。 本着挖坑学习的精神，今天开始会试着一步一步做出一个自己的数据库帮助库 (不敢叫框架，毕竟行业标准里太多 feature，实力不够，做不来 ORZ). 今天就做个雏形吧，雏形的意思就是：看起来好像完成了一些功能，但只是实验性得编码 说明这个帮助库就命名为 ice 吧，请原谅 起名字困难症 ORZ 这是一个 笔记 类型的文章，所有可能会有一些 啊 写到这里才想起来 这样的情况… 本文只引用 mysql-connecter 和 lombok 这两个包。前者是数据库驱动，由于这是个挖坑性质的东西，所以只针对 MYSQL 做功能了；后者是代码生成框架，挺好用的，强烈推荐 也就是说， ice 并不使用常见的数据库连接池，比如 druid、cp30。而是自己实现一个缓存连接获取器，毕竟挖坑就挖深点嘛哈哈。本文假定读者具备一定的 Java 能力，比如 反射、代理 这两个点，有兴趣可以看看我之前的文章。 配置 Configuration用过前边所说的三个框架的同学肯定配过配置文件对吧，我一般配合 spring-boot 使用 spring-data-jpa，所以在 application.properties 配置；其他两个框架则是在传统的 SSH、SSM 环境下配置 application-*.xml。 既然是雏形，那么 ice 前期就直接 code-based configuration 了 (才不是偷懒…) 123456789101112131415/** * Created by krun on 2017/9/22. */@Builder@Data@NoArgsConstructor@AllArgsConstructorpublic class Configuration &#123; private String driverClass; //驱动类名 private String connectionURL; //连接url private String username; //数据库用户名 private String password; //数据库密码&#125; 好，配置就搞定啦，毕竟常见的连接参数都可以直接在 connectionURL 中附带嘛。 连接供应者 ConnectionProvider1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Created by krun on 2017/9/22. */public class ConnectionProvider&#123; /** * 不直接用构造器而是用这种方式获取实例，纯粹是我个人喜好，感觉这样更有 \"通过配置得到\" 的意思。 */ public static CachedConnection configure (Configuration configuration) &#123; return new CachedConnection(configuration); &#125; private Class driverClass = null; private Configuration configuration; private volatile Connection connection; private CachedConnection (Configuration configuration) &#123; this.configuration = configuration; try &#123; // 加载驱动 this.driverClass = Class.forName(this.configuration.getDriverClass( )); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(\"无法加载 JDBC 驱动: \" + this.configuration.getDriverClass( )); &#125; &#125; // 内部用来获取一个新连接 private synchronized Connection create ( ) &#123; // 检查是否已经加载驱动，没有的话抛出异常。 if (driverClass == null) &#123; throw new RuntimeException(\"尚未加载 JDBC 驱动.\"); &#125; else &#123; try &#123; // 获取一个新连接 return DriverManager.getConnection(this.configuration.getConnectionURL( ), this.configuration.getUsername( ), this.configuration.getPassword( )); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; // 暴露给外界获取一个连接，在这里进行 \"是否有可用连接\" 和 \"连接有效性检查\" public synchronized Connection provide( ) throws SQLException &#123; if (connection == null) &#123; connection = createConnection( ); &#125; else if (connection.isClosed( )) &#123; connection = createConnection( ); &#125; return connection; &#125;&#125; Repository模板 Repository这个完全是受 spring-data-jpa 的影响，我觉得”方法映射数据库操作”的映射方式是最吼的，只是 JPA 的接口更简洁些。 12345678910111213/** * Created by krun on 2017/9/22. */public interface Repository&lt;E, I extends Serializable&gt; &#123; List&lt;E&gt; findAll(); //获取表内所有元素 E save(E e); //保存元素，当元素存在id时，尝试更新(update)；不存在id时，尝试插入(insert) long delete(E e); //删除元素 boolean exist(E e); //判断给定元素是否存在&#125; 考虑到实现难度，现在不打算做”方法名解析到sql语句”。因此还是直接引入一个 @Query 注解来设置方法对应的 SQL 操作： 1234567891011/** * Created by krun on 2017/9/22. */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Query &#123; // 暂时也不做别名处理了 String value();&#125; 约定 @Query 注解中的 SQL 语句使用 %s 占位符指明表名(这由 Repository 中 E 解析而来)，用 ? 占位符指定参数，这是为了方便直接把语句放入PreparedStatement使用。 那么结合一下，现在的模板应该是这样的： 12345678910/** * Created by krun on 2017/9/22. */public interface Repository&lt;E, I extends Serializable&gt; &#123; @Query(\"SELECT * FROM %s\") List&lt;E&gt; findAll(); ...&#125; Repository工厂 RepositoryFactory现在用户可以继承 Repository 接口来声明一个指定实体类的 repository，我们需要一个工厂类来为这些接口类创建代理对象(Proxy)以注入我们的方法拦截器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Created by krun on 2017/9/22. */public class RepositoryFactory &#123; //全局工厂的名字 private static final String GLOBAL_FACTORY = \"GLOBAL\"; //用来保存给定名称和其对应的工厂实例 private static final LinkedHashMap&lt;String, RepositoryFactory&gt; factoryMap; static &#123; factoryMap = new LinkedHashMap&lt;&gt;(); &#125; // 这与之前 Connection.configure 的写法一样，纯粹个人喜好。 public static RepositoryFactory configure(Configuration configure) &#123; return RepositoryFactory.configure(GLOBAL_FACTORY, configure); &#125; public static RepositoryFactory configure(String name, Configuration configure) &#123; if (RepositoryFactory.factoryMap.get(name) == null) &#123; synchronized ( RepositoryFactory.factoryMap ) &#123; if (RepositoryFactory.factoryMap.get(name) == null) &#123; RepositoryFactory.factoryMap.put(name, new RepositoryFactory(ConnectionProvider.configure(configure))); &#125; else &#123; throw new RuntimeException(name + \" 的工厂已经被初始化了，不能再对其进行配置。\"); &#125; &#125; &#125; return RepositoryFactory.factoryMap.get(name); &#125; public synchronized static RepositoryFactory get() &#123; return RepositoryFactory.get(GLOBAL_FACTORY); &#125; public synchronized static RepositoryFactory get(String name) &#123; return RepositoryFactory.factoryMap.get(name); &#125; // 每个工厂类实例都持有一个自己的 连接提供者，因为多数情况下全局只会有一个工厂类实例... @Getter private ConnectionProvider connectionProvider; //用于保存每个工厂实例所创建的 repository 实例，用以复用，避免重复创建 repository 实例。 private final LinkedHashMap&lt;Class&lt;? extends Repository&gt;, Repository&gt; repositoryMap; private RepositoryFactory(ConnectionProvider connectionProvider) &#123; this.connectionProvider = connectionProvider; this.repositoryMap = new LinkedHashMap&lt;&gt;(); &#125; // 为 Repository 接口创建代理实例，并注入我们自己的方法拦截器：RepositoryInvocationHandler @SuppressWarnings(\"unchecked\") private &lt;E, I extends Serializable, T extends Repository&lt;E, I&gt;&gt; T getProxy(Class&lt;T&gt; repositoryClass) &#123; return (T) Proxy.newProxyInstance(repositoryClass.getClassLoader(), new Class[] &#123;repositoryClass&#125;, new RepositoryInvocationHandler(this, repositoryClass)); &#125; // 获取给定 repository 类型的代理实例 @SuppressWarnings(\"unchecked\") public &lt;E, I extends Serializable, T extends Repository&lt;E, I&gt;&gt; T getRepository(Class&lt;T&gt; repositoryClass) &#123; T repository; if ((repository = (T) repositoryMap.get(repositoryClass)) == null) &#123; synchronized ( repositoryMap ) &#123; if ((repository = (T) repositoryMap.get(repositoryClass)) == null) &#123; repository = getProxy(repositoryClass); repositoryMap.put(repositoryClass, repository); &#125; &#125; &#125; return repository; &#125;&#125; Repository的灵魂 RepositoryInvocationHandler我们刚才在 RepositoryFactory.getProxy 中创建了一个RepositoryInvocationHandler实例，并传入了RepositoryFactory实例以及代理的Repository类型。 这因为在方法拦截器中，我们需要获取一些东西： 操作的实体类的类型，因为它的全小写形式就是实体类所代表的表的名字 通过工厂类实例获取一个 connection 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Created by krun on 2017/9/22. */public class RepositoryInvocationHandler implements InvocationHandler &#123; private RepositoryFactory factory; //用于保存repository的泛型信息，后面可以比较方便地获取，虽然也可以通过 \"method.getDeclaringClass()\" 来获取，但总觉得麻烦了些。 private Class&lt;? extends Repository&gt; invokeRepositoryClass; public RepositoryInvocationHandler (RepositoryFactory factory, Class&lt;? extends Repository&gt; invokeRepositoryClass) &#123; this.factory = factory; this.invokeRepositoryClass = invokeRepositoryClass; &#125; public Object invoke (Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName( ); // 根据方法名选择合适的 handle方法，以后应该是要改成表驱动，不然太多 if-else 了 ORZ // 说起来，表驱动的话，就有合适的地方暴露接口给用户修改方法映射逻辑了。 if (methodName.startsWith(\"find\")) &#123; return handleFind(method, args); &#125; else if (methodName.startsWith(\"save\")) &#123; &#125; else if (methodName.startsWith(\"delete\")) &#123; &#125; else if (methodName.startsWith(\"exist\")) &#123; &#125; return null; &#125; // 通过保存的 invokeRepositoryClass 获取其持有的泛型信息 private String getEntityName () &#123; if (! Repository.class.isAssignableFrom(this.invokeRepositoryClass)) &#123; throw new RuntimeException(String.format(\"接口 [%s] 并没有继承 Repository\", this.invokeRepositoryClass.getName( ))); &#125; // 这里没有做太多考虑，暂时没遇到问题而已... ParameterizedType parameterizedType = (ParameterizedType) this.invokeRepositoryClass.getGenericInterfaces()[0]; return ((Class)parameterizedType.getActualTypeArguments()[0]).getSimpleName().toLowerCase(); &#125; @SuppressWarnings(\"unchecked\") private Object handleFind (Method method, Object... args) &#123; // 获取方法上的 @Query 注解 Query query = method.getAnnotation(Query.class); if (query == null) &#123; throw new IllegalArgumentException(\"也许你忘了为 \" + method.getDeclaringClass( ).getSimpleName( ) + \".\" + method.getName( ) + \"() 设置 @Query 注解\"); &#125; // java 7的 \"try-with-resource\" 语法糖，挺方便的，不用操心 connection 关没关了 // 突然想起来，这样写的话好像... ConnectionProvider 就没用了啊 ... ORZ try (Connection connection = factory.getConnectionProvider().provide()) &#123; PreparedStatement preparedStatement = (PreparedStatement) connection //简单得替换一下表名占位符 .prepareStatement(String.format(query.value(), getEntityName())); // 粗暴得把参数都塞进去... // 以后估计要做个 switch-case 把参数类型检查做一下 for (int i = 1; i &lt;= args.length; i++) &#123; preparedStatement.setObject(i, args[i - 1]); &#125; System.out.println(preparedStatement.asSql()); // 把结果打出来看看 ResultSet resultSet = preparedStatement.executeQuery(); ResultSetMetaData metaData = resultSet.getMetaData(); while (resultSet.next()) &#123; for (int i = 1; i &lt;= metaData.getColumnCount(); i++) &#123; System.out.print(String.valueOf(resultSet.getObject(i)) + \"\\t\"); &#125; System.out.println(); &#125; resultSet.close(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; // 同样的简单粗暴，只为了看效果哈哈 try &#123; // 注：这种写法在 \"List&lt;Student&gt; findAll()\" 这种情况会报错，因为 List 是接口，无法为其创建实例 return method.getReturnType().newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace( ); &#125; return null; &#125;&#125; 最后12345678910111213141516171819202122232425262728293031323334353637383940/** * Created by krun on 2017/9/22. */public class App &#123; @Data public static class Student &#123; private String id; private String name; &#125; interface StudentRepository extends Repository&lt;Student, String&gt; &#123; @Query(\"SELECT * FROM %s WHERE gender = ?\") List&lt;Student&gt; findByGender(String gender); @Query(\"SELECT * FROM %s WHERE id &gt; ?\") List&lt;Student&gt; findByIdAfter(String id); @Query(\"SELECT * FROM %s WHERE name = ?\") Student findByName(String name); &#125; public static void main(String[] args ) &#123; RepositoryFactory factory = RepositoryFactory.configure(Configuration.builder() .driverClass(\"com.mysql.jdbc.Driver\") .connectionURL(\"jdbc:mysql://localhost:3306/hsc\") .username(\"gdpi\") .password(\"gdpi\") .build()); StudentRepository studentRepository = factory.getRepository(StudentRepository .class); studentRepository .findByName(\"krun\"); &#125;&#125;&gt; SELECT * FROM student WHERE name = 'krun'&gt; 20152200000 计算机技术系 男 2015 软件技术 krun","tags":[{"name":"MySQL数据库","slug":"MySQL","permalink":"http://hunterblog.cn/tags/MySQL/"}]},{"title":"(转)通过反射动态修改注解的某个属性","date":"2017-09-19T15:36:47.000Z","path":"2017/09/19/Z_JavaReflexChangeAttribute.html","text":"原文出处： [Java]通过反射，动态修改注解的某个属性值 ，作者：krun 昨晚看到一条问题，大意是楼主希望可以动态得建立多个Spring 的定时任务。 这个题目我并不是很熟悉，不过根据题目描述和查阅相关 Spring 创建定时任务 的资料，发现这也许涉及到通过Java代码动态修改注解的属性值。 今天对此尝试了一番，发现通过反射来动态修改注解的属性值是可以做到的： 众所周知，java/lang/reflect 这个包下面都是Java的反射类和工具。 Annotation 注解，也是位于这个包里的。注解自从Java 5.0版本引入后，就成为了Java平台中非常重要的一部分，常见的如 @Override、 @Deprecated。 关于注解更详细的信息和使用方法，网上已经有很多资料，这里就不再赘述了。一个注解通过 @Retention 指定其生命周期，本文所讨论的动态修改注解属性值，建立在 @Retention(RetentionPolicy.RUNTIM) 这种情况。毕竟这种注解才能在运行时(runtime)通过反射机制进行操作。 那么现在我们定义一个 @Foo 注解，它有一个类型为 String 的 value 属性，该注解应用再Field上: 123456789/** * Created by krun on 2017/9/18. */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Foo &#123; String value();&#125; 再定义一个普通的Java对象 Bar，它有一个私有的String属性 val，并为它设置属性值为&quot;fff&quot; 的 @Foo 注解: 123456public class Bar &#123; @Foo (\"fff\") private String val;&#125; 接下来在 main 方法中我们来尝试修改 Bar.val 上的 @Foo注解的属性值为 &quot;ddd&quot;。 先是正常的获取注解属性值: 123456789101112131415161718/** * Created by krun on 2017/9/18. */public class Main &#123; public static void main(String ...args) throws NoSuchFieldException &#123; //获取Bar实例 Bar bar = new Bar(); //获取Bar的val字段 Field field = Bar.class.getDeclaredField(\"val\"); //获取val字段上的Foo注解实例 Foo foo = field.getAnnotation(Foo.class); //获取Foo注解实例的 value 属性值 String value = foo.value(); //打印该值 System.out.println(value); // fff &#125;&#125; 首先，我们要知道注解的值是存在哪里的。 在 String value = foo.value(); 处下断点，我们跑一下可以发现： 当前栈中有这么几个变量，不过其中有一点很特别：foo，其实是个Proxy实例。 Proxy也是 java/lang/reflect下的东西，它的作用是为一个Java类生成一个代理，就像这样： 12345678910111213141516171819202122232425262728293031323334353637public interface A &#123; String func1();&#125;public class B implements A &#123; @Override public String func1() &#123; //do something ... &#125; public String func2() &#123; //do something ... &#125;;&#125;public static void main(String ...args) &#123; B bInstance = new B(); B bProxy = Proxy.newProxyInstance( B.class.getClassLoader(), // B 类的类加载器 B.class.getInterfaces(), // B 类所实现的接口，如果你想拦截B类的某个方法，必须让这个方法在某个接口中声明并让B类实现该接口 new InvocationHandler() &#123; // 调用处理器，任何对 B类所实现的接口方法的调用都会触发此处理器 @Override public Object invoke (Object proxy, // 这个是代理的实例，method.invoke时不能使用这个，否则会死循环 Method method, // 触发的接口方法 Object[] args // 此次调用该方法的参数 ) throws Throwable &#123; System.out.println(String.format(\"调用 %s 之前\", method.getName())); /** * 这里必须使用B类的某个具体实现类的实例，因为触发时这里的method只是一个接口方法的引用， * 也就是说它是空的，你需要为它指定具有逻辑的上下文(bInstance)。 */ Object obj = method.invoke(bInstance, args); System.out.println(String.format(\"调用 %s 之后\", method.getName())); return obj; //返回调用结果 &#125; &#125; );&#125; 这样你就可以拦截这个Java类的某个方法调用，但是你只能拦截到 func1的调用，想想为什么？ 那么注意了： ClassLoader 这是个class就会有，注解也不例外。那么注解和interfaces有什么关系? 注解本质上就是一个接口，它的实质定义为: interface SomeAnnotation extends Annotation。这个 Annotation 接口位于 java/lang/annotation 包，它的注释中第一句话就是 The common interface extended by all annotation types. 如此说来，Foo 注解本身只是个接口，这就意味着它没有任何代码逻辑，那么它的 value 属性究竟是存在哪里的呢？ 展开 foo 可以发现： 这个 Proxy 实例持有一个 AnnotationInvocationHandler，还记得之前提到过如何创建一个 Proxy 实例么? 第三个参数就是一个 InvocationHandler。看名字这个handler即是Annotation所特有的，我们看一下它的代码： 12345678910class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; private final Class&lt;? extends Annotation&gt; type; private final Map&lt;String, Object&gt; memberValues; private transient volatile Method[] memberMethods = null; /* 后续无关代码就省略了，想看的话可以查看 sun/reflect/annotation/AnnotationInvocationHandler */ &#125; 我们一眼就可以看到一个有意思的名字: memberValues，这是一个Map，而断点中可以看到这是一个 LinknedHashMap，key为注解的属性名称，value即为注解的属性值。 现在我们找到了注解的属性值存在哪里了，那么接下来的事就好办了： 1234567891011121314151617181920212223242526/** * Created by krun on 2017/9/18. */public class Main &#123; public static void main(String ...args) throws NoSuchFieldException, IllegalAccessException &#123; //获取Bar实例 Bar bar = new Bar(); //获取Bar的val字段 Field field = Bar.class.getDeclaredField(\"val\"); //获取val字段上的Foo注解实例 Foo foo = field.getAnnotation(Foo.class); //获取 foo 这个代理实例所持有的 InvocationHandler InvocationHandler h = Proxy.getInvocationHandler(foo); // 获取 AnnotationInvocationHandler 的 memberValues 字段 Field hField = h.getClass().getDeclaredField(\"memberValues\"); // 因为这个字段事 private final 修饰，所以要打开权限 hField.setAccessible(true); // 获取 memberValues Map memberValues = (Map) hField.get(h); // 修改 value 属性值 memberValues.put(\"value\", \"ddd\"); // 获取 foo 的 value 属性值 String value = foo.value(); System.out.println(value); // ddd &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://hunterblog.cn/tags/Java/"},{"name":"反射","slug":"Reflex","permalink":"http://hunterblog.cn/tags/Reflex/"}]},{"title":"Java四大线程池概述","date":"2017-08-20T14:26:33.000Z","path":"2017/08/20/Java-ThreadPool01.html","text":"前言：Java为了提高线程的使用效率，JDK1.5开始为我们提供了线程池，大大提高了我们的开发效率，也节省了计算机资源的消耗。下面我们将来简单介绍一下四种线程池的用法。 四大线程池一、newFixedThreadPool newFixedThreadPool方法创建的是一个定长的线程池，该线程池一旦创建，线程数量就已经固定了，因此在线程数量达到最大值的时候，新的执行任务需要在队列任务中等待，直到有空闲线程才得以继续执行。 构造方法： 1234567891011121314/*1.默认创建一个无限大的线程池*/public static ExecutorService newFixedThreadPool(int nThreads)nThreads - 池中的线程数 /*2.创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程*/public static ExecutorService newFixedThreadPool(int nThreads,ThreadFactory threadFactory)nThreads - 池中的线程数 threadFactory - 创建新线程时使用的工厂 代码演示12345678910111213141516171819202122232425262728package com.threadpool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 创建一个定长的线程池，可以有效地控制最大并发数量，超出的线程会在队列中等待 * @author Administrator * */public class FixedThreadPoolTest &#123; public static void main(String[] args) &#123; test(); &#125; private static void test() &#123; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 5; i++) &#123; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread()); &#125; &#125;); &#125; &#125;&#125; 运行结果如下： 1234Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-2,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-3,5,main] 注：上面的Thread代表线程名称，pool-1-thread-1代表第几个线程池中的第几条线程，5代表的是线程的优先级，main代表是在主线程中执行。下面的运行结果也一样 二、newCachedThreadPool newCachedThreadPool是创建一个带缓存的线程池，可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。 构造方法：12345678910/*1.默认创建一个带缓存的线程池*/public static ExecutorService newCachedThreadPool()/*2.创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程*/public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)threadFactory - 创建新线程时使用的工厂 代码演示1234567891011121314151617181920212223242526272829package com.threadpool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 创建一个带缓存的线程池 * 该线程池的数量无限大(其实是Integer.MAX_VALUE) * @author Administrator * */public class CachedThreadPoolTest &#123; public static void main(String[] args) &#123; test(); &#125; private static void test() &#123; ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; cachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread()); &#125; &#125;); &#125; &#125;&#125; 运行结果如下：12345678910Thread[pool-1-thread-2,5,main]Thread[pool-1-thread-3,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-4,5,main]Thread[pool-1-thread-6,5,main]Thread[pool-1-thread-5,5,main]Thread[pool-1-thread-7,5,main]Thread[pool-1-thread-8,5,main]Thread[pool-1-thread-10,5,main]Thread[pool-1-thread-9,5,main] 三、newScheduledThreadPool newScheduledThreadPool是一个可以延时执行或者周期性执行的线程池，相当于timer，但比timer更加安全、强大。 构造方法 1234567891011121314/*1.默认创建一个能延时或者周期性执行的线程池*/public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)corePoolSize - 池中所保存的线程数，即使线程是空闲的也包括在内/*2.使用工厂模式创建一个线程池，可以调度命令在一个给定的延迟后运行，或周期性地执行。 */public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize,ThreadFactory threadFactory)corePoolSize - 池中所保存的线程数，即使线程是空闲的也包括在内threadFactory - 执行程序创建新线程时使用的工厂 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142package com.threadpool;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;/** * 创建一个定时或者周期性执行的线程池 * @author Administrator * */public class ScheduledThreadPoolTest &#123; private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); public static void main(String[] args) &#123; test(); &#125; private static void test() &#123; //3秒后执行任务，只会被执行一次 scheduledThreadPool.schedule(new Runnable() &#123; @Override public void run() &#123; //doSomethings System.out.println(Thread.currentThread() + \" 只执行一次任务\"); &#125; &#125;, 3000, TimeUnit.MILLISECONDS); //3秒后任务得到一次执行,后面每隔2秒执行一次 scheduledThreadPool.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; //doSomethings System.out.println(Thread.currentThread() + \" 反复执行任务\"); &#125; &#125;, 3000, 2000, TimeUnit.MILLISECONDS); &#125;&#125; 运行结果如下：(由于该线程池中的线程会一直执行下去，因此只选择部分结果作为展示) 12345678Thread[pool-1-thread-1,5,main] 只执行一次任务Thread[pool-1-thread-2,5,main] 反复执行任务Thread[pool-1-thread-1,5,main] 反复执行任务Thread[pool-1-thread-2,5,main] 反复执行任务Thread[pool-1-thread-3,5,main] 反复执行任务Thread[pool-1-thread-3,5,main] 反复执行任务 ......Thread[pool-1-thread-5,5,main] 反复执行任务 拓展：TimeUnit的参数有7个，分别为 DAYS：天 HOURS：小时 MINUTES ：分钟 SECONDS：秒 MILLISECONDS：毫秒 千分之一秒 MICROSECONDS：微秒 一百万分之一秒（就是毫秒/1000） NANOSECONDS：毫微秒 十亿分之一秒（就是微秒/1000） 四、newSingleThreadExecutor newSingleThreadExecutor是一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。虽然该线程池和直接创建一个子线程差别不大，但是 该线程池能够将短时间内需要按顺序执行的任务得到很好的实现。 构造方法 1234567891011/*1.默认创建一个单线程的Executor*/public static ExecutorService newSingleThreadExecutor()/*2.使用ThreadFactory来创建线程池*/public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)threadFactory - 创建新线程时使用的工厂 代码演示： 12345678910111213141516171819202122232425262728293031package com.threadpool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 创建一个单例的线程池 * @author Administrator * */public class SingleThreadExecutorTest &#123; public static void main(String[] args) &#123; test(); &#125; private static void test() &#123; ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; singleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread()); &#125; &#125;); &#125; &#125;&#125; 运行结果如下： 12345678910Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main]Thread[pool-1-thread-1,5,main] 总结通过对四大常用线程池的一个简单了解，能够让我们在代码编写和优化上得到一定的提高，如需深入体验其强大之处，还得对该部分源码进行详细的阅读和剖析。 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"Java","slug":"Java","permalink":"http://hunterblog.cn/tags/Java/"},{"name":"JavaBase","slug":"JavaBase","permalink":"http://hunterblog.cn/tags/JavaBase/"}]},{"title":"JavaSe基础概述","date":"2017-04-01T14:26:33.000Z","path":"2017/04/01/J2SE.html","text":"前言：此文主要对Java基础进行概述，让大家对Java基础体系有个大致的了解 基础 八种基本数据类型的大小，以及他们的封装类。八种基本数据类型，int ,double ,long ,float, short,byte,character,boolean 对应的封装类型是：Integer ,Double ,Long ,Float, Short,Byte,Character,Boolean Switch能否用string做参数？在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 equals与==的区别。http://www.importnew.com/6804.html ==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。equals()方法最重要的一点是，能够根据业务要求去重写，按照自定义规则去判断两个对象是否相等。重写equals()方法的时候，要注意一下hashCode是否会因为对象的属性改变而改变，否则在使用散列集合储存该对象的时候会碰到坑！！理解equals()方法的存在是很重要的。 使用==比较有两种情况： 比较基础数据类型(Java中基础数据类型包括八中：short,int,long,float,double,char,byte,boolen)：这种情况下，==比较的是他们的值是否相等。 引用间的比较：在这种情况下，==比较的是他们在内存中的地址，也就是说，除非引用指向的是同一个new出来的对象，此时他们使用`==`去比较得到true，否则，得到false。 使用equals进行比较： equals追根溯源，是Object类中的一个方法，在该类中，equals的实现也仅仅只是比较两个对象的内存地址是否相等，但在一些子类中，如：String、Integer 等，该方法将被重写。 以String类为例子说明eqauls与==的区别： 在开始这个例子之前，同学们需要知道JVM处理String的一些特性。Java的虚拟机在内存中开辟出一块单独的区域，用来存储字符串对象，这块内存区域被称为字符串缓冲池。当使用String a = &quot;abc&quot;这样的语句进行定义一个引用的时候，首先会在字符串缓冲池中查找是否已经相同的对象，如果存在，那么就直接将这个对象的引用返回给a，如果不存在，则需要新建一个值为”abc”的对象，再将新的引用返回a。String a = new String(&quot;abc&quot;);这样的语句明确告诉JVM想要产生一个新的String对象，并且值为”abc”，于是就在堆内存中的某一个小角落开辟了一个新的String对象。 ==在比较引用的情况下，会去比较两个引用的内存地址是否相等。 123456789String str1 = &quot;abc&quot;;String str2 = &quot;abc&quot;;System.out.println(str1 == str2);System.out.println(str1.equals(str2));String str2 = new String(&quot;abc&quot;);System.out.println(str1 == str2);System.out.println(str1.equals(str2)); 以上代码将会输出 true true false true 第一个true：因为在str2赋值之前，str1的赋值操作就已经在内存中创建了一个值为”abc”的对象了，然后str2将会与str1指向相同的地址。 第二个true：因为String已经重写了equals方法：为了方便大家阅读我贴出来，并且在注释用进行分析： 1234567891011121314151617181920212223242526272829 public boolean equals(Object anObject) &#123; //如果比较的对象与自身内存地址相等的话 //就说明他两指向的是同一个对象 //所以此时equals的返回值跟==的结果是一样的。 if (this == anObject) &#123; return true; &#125; //当比较的对象与自身的内存地址不相等，并且 //比较的对象是String类型的时候 //将会执行这个分支 if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; //在这里循环遍历两个String中的char while (n-- != 0) &#123; //只要有一个不相等，那么就会返回false if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 进行以上分析之后，就不难理解第一段代码中的实例程序输出了。 Object有哪些公用方法？http://www.cnblogs.com/yumo/p/4908315.html 1．clone方法保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。 2．getClass方法final方法，获得运行时类型。 3．toString方法该方法用得比较多，一般子类都有覆盖。 4．finalize方法该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 5．equals方法该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 6．hashCode方法该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hashCode()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 如果不重写hashCode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。 7．wait方法wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 （1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 8．notify方法该方法唤醒在该对象上等待的某个线程。 9．notifyAll方法该方法唤醒在该对象上等待的所有线程。 Java的四种引用，强弱软虚，用到的场景。JDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的. 强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。 软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null 弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。和软引用加入队列的时机相同 虚引用（Phantom Reference)又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了.虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有 Hashcode的作用。http://c610367182.iteye.com/blog/1930676 以Java.lang.Object来理解,JVM每new一个Object,它都会将这个Object丢到一个Hash哈希表中去,这样的话,下次做Object的比较或者取这个对象的时候,它会根据对象的hashcode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。具体过程是这样: new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。 比较两个对象的时候,首先根据他们的hashcode去hash表中找他的对象,当两个对象的hashcode相同,那么就是说他们这两个对象放在Hash表中的同一个key上,那么他们一定在这个key上的链表上。那么此时就只能根据Object的equal方法来比较这个对象是否equal。当两个对象的hashcode不同的话，肯定他们不能equal. String、StringBuffer与StringBuilder的区别。Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。 try catch finally，try里有return，finally还执行么？会执行，在方法 返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是纪录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法规定不能做这样的事。 Excption与Error区别Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的状况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。http://www.cnblogs.com/yumo/p/4909617.html Java异常架构图 ThrowableThrowable是 Java 语言中所有错误或异常的超类。Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。 ExceptionException及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。 RuntimeExceptionRuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ Error和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。和RuntimeException一样， 编译器也不会检查Error。 Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。 (01) 运行时异常定义 : RuntimeException及其子类都被称为运行时异常。特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ (02) 被检查的异常定义 : Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。被检查异常通常都是可以恢复的。 (03) 错误定义 : Error类及其子类。特点 : 和运行时异常一样，编译器也不会对错误进行检查。当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。按照Java惯例，我们是不应该是实现任何新的Error子类的！ 对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是： 对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。 OOM： OutOfMemoryError异常 除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能， Java Heap 溢出 一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。 出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。 如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。 虚拟机栈和本地方法栈溢出 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常 这里需要注意当栈的大小越大可分配的线程数就越少。 运行时常量池溢出 异常信息：java.lang.OutOfMemoryError:PermGen space 如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。 方法区溢出 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。 异常信息：java.lang.OutOfMemoryError:PermGen space 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。 Java面向对象的三个特征与含义。继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 Override和Overload的含义与区别。Overload：顾名思义，就是Over(重新)——load（加载），所以中文名称是重载。它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、类型不能相同；或者说可以改变参数、类型但是函数名字依然不变。 Override：就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 Interface与abstract类的区别。抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 Static class 与non static class的区别。内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。 java多态的实现原理。http://blog.csdn.net/zzzhangzhun/article/details/51095075 当JVM执行Java字节码时，类型信息会存储在方法区中，为了优化对象的调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。 方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。方法区的内存回收目标是针对常量池的回收及对类型的卸载。 方法表的构造 由于java的单继承机制，一个类只能继承一个父类，而所有的类又都继承Object类，方法表中最先存放的是Object的方法，接下来是父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。 由于这样的特性，使得方法表的偏移量总是固定的，例如，对于任何类来说，其方法表的equals方法的偏移量总是一个定值，所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。 实例 假设Class A是Class B的子类，并且A改写了B的方法的method()，那么B来说，method方法的指针指向B的method方法入口；对于A来说，A的方法表的method项指向自身的method而非父类的。 流程：调用方法时，虚拟机通过对象引用得到方法区中类型信息的方法表的指针入口，查询类的方法表 ，根据实例方法的符号引用解析出该方法在方法表的偏移量，子类对象声明为父类类型时，形式上调用的是父类的方法，此时虚拟机会从实际的方法表中找到方法地址，从而定位到实际类的方法。注：所有引用为父类，但方法区的类型信息中存放的是子类的信息，所以调用的是子类的方法表。 foreach与正常for循环效率对比。http://904510742.iteye.com/blog/2118331 直接for循环效率最高，其次是迭代器和 ForEach操作。作为语法糖，其实 ForEach 编译成 字节码之后，使用的是迭代器实现的，反编译后，testForEach方法如下： 123456public static void testForEach(List list) &#123; for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123; Object t = iterator.next(); Object obj = t; &#125; &#125; 可以看到，只比迭代器遍历多了生成中间变量这一步，因为性能也略微下降了一些。 反射机制JAVA反射机制是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 对于任意一个对象, 都能够调用它的任意一个方法和属性; 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制. 主要作用有三： 运行时取得类的方法和字段的相关信息。 创建某个类的新实例(.newInstance()) 取得字段引用直接获取和设置对象字段，无论访问修饰符是什么。 用处如下： 观察或操作应用程序的运行时行为。 调试或测试程序，因为可以直接访问方法、构造函数和成员字段。 通过名字调用不知道的方法并使用该信息来创建对象和调用方法。 String类内部实现，能否改变String对象内容String源码分析 http://blog.csdn.net/zhangjg_blog/article/details/18319521 try catch 块，try里有return，finally也有return，如何执行http://qing0991.blog.51cto.com/1640542/1387200 泛型的优缺点优点： 使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。 泛型最常见的用途是创建集合类。 缺点： 在性能上不如数组快。 泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt; 能，但是利用类都继承自Object，所以使用是每次调用里面的函数都要通过强制转换还原回原来的类，这样既不安全，运行速度也慢。 解析XML的几种方式的原理与特点：DOM、SAX、PULL。http://www.cnblogs.com/HaroldTihan/p/4316397.html Java与C++对比。http://developer.51cto.com/art/201106/270422.htm Java1.7与1.8新特性。http://blog.chinaunix.net/uid-29618857-id-4416835.html JNI的使用。http://landerlyoung.github.io/blog/2014/10/16/java-zhong-jnide-shi-yong/ 集合ArrayList、LinkedList、Vector的底层实现和区别 从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。 从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。 HashMap和HashTable的底层实现和区别，两者和ConcurrentHashMap的区别。http://blog.csdn.net/xuefeng0707/article/details/40834595 HashTable线程安全则是依靠方法简单粗暴的sychronized修饰，HashMap则没有相关的线程安全问题考虑。。 在以前的版本貌似ConcurrentHashMap引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。 通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍。 HashMap的hashcode的作用？什么时候需要重写？如何解决哈希冲突？查找的时候流程是如何？从源码分析HashMap Arraylist和HashMap如何扩容？负载因子有什么作用？如何保证读写进程安全？http://m.blog.csdn.net/article/details?id=48956087 http://hovertree.com/h/bjaf/2jdr60li.htm ArrayList 本身不是线程安全的。所以正确的做法是去用 java.util.concurrent 里的 CopyOnWriteArrayList 或者某个同步的 Queue 类。 HashMap实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须 保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问. TreeMap、HashMap、LinkedHashMap的底层实现区别。http://blog.csdn.net/lolashe/article/details/20806319 Collection包结构，与Collections的区别。Collection是一个接口，它是Set、List等容器的父接口；Collections是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 Set、List之间的区别是什么?http://developer.51cto.com/art/201309/410205_all.htm Map、Set、List、Queue、Stack的特点与用法。http://www.cnblogs.com/yumo/p/4908718.html Collection 是对象集合， Collection 有两个子接口 List 和 Set List 可以通过下标 (1,2..) 来取得值，值可以重复 而 Set 只能通过游标来取值，并且值是不能重复的 ArrayList ， Vector ， LinkedList 是 List 的实现类 ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的 LinkedList 是线程不安全的，底层是由链表实现的 Map 是键值对集合 HashTable 和 HashMap 是 Map 的实现类HashTable 是线程安全的，不能存储 null 值HashMap 不是线程安全的，可以存储 null 值 Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。 Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。","tags":[{"name":"Java基础","slug":"JavaBase","permalink":"http://hunterblog.cn/tags/JavaBase/"},{"name":"Java","slug":"Java","permalink":"http://hunterblog.cn/tags/Java/"}]},{"title":"MySQL语句","date":"2017-03-20T15:36:47.000Z","path":"2017/03/20/MySQL-USE1.html","text":"前言：本文主要讲解的对数据库的管理 navicat破解教程及文件：链接：https://pan.baidu.com/s/1kVcALzL 密码：p5u5 1. 数据库入门在我们编程开发中，经常会涉及到对数据的操作，而操作数据的途径大致有三种，分别是内存、文件和数据库软件啦1.1 保存数据的途径： 将数据保存到内存：优点：读写速度很快缺点：程序一旦异常关闭将会导致数据丢失 将数据保存到文件：优点：数据可以永久保存缺点：频繁地操作IO，效率大大降低；数据管理不方便，例如查询某个数据时需要全部读取出来，再进行匹配 将数据保存到数据库软件：优点：数据可以永久地保存下来；管理数据非常方便快捷 2. MySQL数据存储的结构首先要有数据库，再到表，最终才有数据 3. 数据库的管理3.1 查询所有的数据库 show databases; 3.2 创建数据库 create database 数据库名 3.3 查看数据库的默认字符集 show create database 数据库名； 3.4 删除数据库 drop database 数据库名称; 3.5 修改数据库默认字符集 alter database 数据库名称 default character set gbk; 4.表的管理注意：在对表进行增删改查的时候，必须先选择数据库，否则会出现一个错误：No database selected 错误码为1046 选择数据库 use 数据库名称; 首先介绍一下MySQL常用的字段类型1.串数据类型 数值类型 说明 CHAR 1~255个字符的定长串，它的长度必须在创建时指定，否则MySQL假定为CHAR（1） VARCHAR 可变长度，最多不超过255字节，如在创建时指定VARCHAR（n），则可存储0~n个字符的变长串 TINYTEXT 同TEXT，最大长度为255字节 MEDUIMTEXT 同TEXT，最大长度为16K TEXT 最大长度为64K的变长文本 2.日期和时间数据类型 数据类型 格式&amp;取值范围 DATE YYYY-MM-DD1000-01-01——9999-12-31 TIME HH：MM：SS-838:59:59——838:59:59 DATETIME YYYY-MM-DD HH：MM：SS1000-01-01 00:00:00——9999-12-31 23:59:59 YEAR 1901——2155 3.二进制数据类型 数据类型 说明 TITYBLOB 最大长度为255字节 BLOB 最大长度为64KB MEDIUMBLOB 最大长度为16MB LONGBLOB 最大长度为4GB 4.1 查看所有表 show tables; 4.2 创建表 create table 表名称(字段名称1 字段类型,字段名称2 字段类型,……字段名称n 字段类型); 4.3 查看表结构 desc 表名称; 4.4 删除表 drop table 表名称; 4.5 修改表 4.5.1 添加字段 alter table 表名 add [column (可选)] 字段名 字段类型; 4.5.2 删除字段 alter table 表名 drop [column] 字段名; 4.5.3 修改字段类型 alter table 表名 modify [column] remark 新字段类型; 4.5.4 修改字段名称 alter table 表名 change [cloumn] 原字段名 新字段名 新字段数据类型; 4.5.5 修改表名称 alter table 表名 rename to 新表名; 5. 数据的管理5.1 增加数据 方式一：插入所有字段(插入所有字段，必须要按顺序依次插入(如果类型或者插入顺序不对，将会添加数据失败)) INSERT INTO 表名 VALUES(值1,值2, …… ,值n); 方式二：插入指定字段数据 INSERT INTO 表名(字段1,字段2, … ) VALUES(值1,值2, … ); 5.2 删除数据 1.删除所有数据(建议少用) 方式一：DELETE FROM 表名; 方式二：TRUNCATE TABLE 表名; (此方法删除数据可以删除表约束，后面会提及约束) 2.带条件的删除(推荐使用) DELETE FROM 表名 where 条件表达式; 例如删除id=2的数据：DELETE FROM 表名 WHERE id=2; 5.3修改数据 1.修改所有数据(建议少用) UPDATE 表名 set 字段名=值; 2.带条件修改一个字段的值(推荐使用) UPDATE 表名 字段=要修改的值 WHERE 条件表达式; (例如修改id为1的数据，t条件表达式就是id=1) 3.带条件修改多个字段的值 (多个字段之间用,隔开) UPDATE student SET 字段1=值1,字段2=值2, … WHERE 条件表达式; 6. 查询数据(重点)注意：在查询数据的时候可以使用别名替换字段名称，格式：字段名 AS &#39;别名&#39;6.1 查询所有数据 SELECT * FROM 表名; 6.2 查询指定列 SELECT 字段1,字段2,字段3, … FROM 表名; 6.3 查询时添加常量列 需求：在查询时添加一个字段(也就是常量列) SELECT 字段1,字段2, … ,常量字段 FROM 表名; 6.4 查询时合并列 需求：一个学生含有chinese和math这两个字段，查询时只查询两者的总分就是合并列查询注意：合并列查询只能合并数值类型的字段，对于字符串类型的数值不能合并 SELECT (chinese+matn) AS ‘总成绩’ FROM 表名; 6.5 查询时取出重复记录 SELECT DISTINCT 字段名 FROM 表名; 6.6 条件查询 6.6.1 逻辑条件 符号：AND(与) 、OR(或)需求1：查询id为1并且name为lisi的数据 SELECT * FROM 表名 WHERE id=2 AND name=’lisi’; 需求2：查询id为1或name为lisi的数据 SELECT * FROM 表名 WHERE id=2 OR name=’lisi’; 6.6.2 比较条件 符号：&gt;(大于)、&lt;(小于)、&gt;=(大于等于)、&lt;=(小于等于)、=(等于)、&lt;&gt;(不等于)、between and(等价于&gt;= 且 &lt;=，包括头包括尾) 需求1：在student表中查询math成绩大于等于80分并且小于等于90分的学生 SELECT * FROM student WHERE math &gt;= 80 AND math &lt;=90; 或 SELECT * FROM student WHERE math between 80 and 90; 6.6.3 判空条件 符号： is null(为null)、is not null(不为null)、=‘’(等于空字符串)、&lt;&gt;‘’(不等于空字符串)需求：查询一个包含address字段的student表不为null和空串的数据 SELECT * FROM student WHERE address is not null and address&lt;&gt;’ ‘; 6.6.4 模糊条件 符号：LIKE、_(一个下划线代表一个字符)、%(代表任意个字符)需求1：查询某表中name字段中姓李的数据 SELECT * FROM 表名 WHERE name LIKE ‘李%’; 需求2：查询某表中name字段中姓李并只有两个字的数据 SELECT * FROM 表名 WHERE name LIKE ‘李_’; 6.7 聚合查询(使用聚合函数) 常用的聚合函数有：求和sum()、求平均值avg()、求最大值max()、求最小值min()、求数量之和count()需求1：查询student表中所有学生math成绩之和 SELECT sum(math) AS ‘math成绩总分’ FROM student; 需求2: 查询student表中math的平均分 SELECT avg(math) AS ‘math的平均分’ FROM student; 需求3：查询student表中math成绩最高分的学生信息 SELECT max(math) AS ‘math最高分’ FROM student; 需求4：查询student表中math成绩最低分的学生信息 SELECT min(math) AS ‘math最低分’ FROM student; 需求5：查询表中有多少条数据 SELECT count(*) FROM 表名; 注意：count() 函数统计的数量不包含null的数据 //=========未完待续=======\\\\","tags":[{"name":"MySQL数据库","slug":"MySQL","permalink":"http://hunterblog.cn/tags/MySQL/"}]},{"title":"JavaSe之集合(上)","date":"2017-03-09T10:07:13.000Z","path":"2017/03/09/JavaSe_Colleacion1.html","text":"前言：本文主要介绍Collection根接口(也被成为单列集合)下常用集合的特点和使用方法 1. 集合概述由于我们开发过程中，难以避免不去操作数据，操作对象就有可能对数据进行存储，存储数据的方式多种多样，之前我们都是将数据存储在数组中，但数组的特点是长度固定不可改变的，这样就不适合用于存储变化(个数的变化)的数据。因此，Java提供一种容器用于存储数据，这个容器就叫做集合。 2. 集合和数组的区别数组： 长度固定 可以存储基本数据类型，也可以存储引用数据类型 存储的数据类型必须要一致(比如说创建一个int类型的数组，它就只能存整数，不能存double或者String类型等) 集合： 长度可变 只能存储引用数据类型 可以存储不同类型的对象。(可以存int、String、double等) 3. 集合的体系： 4.下面看一下各成员特点|- - List：有序(序指的是存和取得顺序一致，怎么样存就怎么样取)，元素可以重复|- - - - - - - ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高|- - - - - - - Vector：底层数据结构是数组，查询快，增删慢，线程安全，效率低|- - - - - - - LinkedList：底层数据结构是链表，查询慢，增删快，线程不安全，效率高 |- - Set：无序，元素不可以重复|- - - - - - - HashSet：底层数据结构是哈希表，线程不安全，效率高|- - - - - - - TreeSet：底层数据结构是二叉树，线程不安全，效率高 5. Collection接口中的常用方法注：Collection是一个根接口，继承它的子类或者子接口都能使用它的方法 6. List集合特有的方法 7. ArrayListArrayList是List接口下的一个实现类之一，也是最常用的一个集合，由于它的底层是数组结构实现的，因此可以看成是一个长度可变的数组，下面介绍关于ArrayList的常见使用123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; //定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(\"你好\"); //添加元素 arrayList.add(20); arrayList.add(20); //添加了重复元素 arrayList.set(0, \"hello\"); //修改了索引为0的元素 int size = arrayList.size(); //获取集合的大小 System.out.println(\"集合的大小为：\"+size); //输出：集合的大小为：3 System.out.println(arrayList.get(2)); //输出：20 System.out.println(arrayList); //输出：[hello, 20, 20] &#125; &#125; 7.1 集合的遍历1.通过集合转数组，然后再对数组进行遍历12345678910Collection c = new ArrayList(); c.add(\"abc\"); c.add(\"abcd\"); c.add(\"abcde\"); Object[] array = c.toArray(); //将集合转为数组 for(int i=0; i&lt;array.length; i++)&#123; //遍历输出 String str = (String)array[i]; System.out.println(str.toUpperCase());&#125; 2.通过get()和size()方法结合(仅仅适用于Collection的子接口List接口)1234567891011//定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(10); arrayList.add(50); arrayList.add(\"你好\"); arrayList.add(8); for (int i = 0; i &lt; arrayList.size(); i++) &#123; Object obj = arrayList.get(i); //根据索引获取值，在此返回的是Object数据类型 System.out.print(obj + \" \"); &#125; 3.通过迭代器实现(适用于所有集合) (下面将会介绍)12345678910111213141516//定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(10); arrayList.add(50); arrayList.add(\"你好\"); arrayList.add(8); //第一步：创建迭代器对象 Iterator iterator = arrayList.iterator(); //第二步：通过hasNext()方法判断迭代器中是否有元素 while (iterator.hasNext()) &#123; //第三步：通过next()方法获取元素 Object object = iterator.next(); System.out.print(object + \"\"); &#125;&#125; 4.通过增强for循环遍历(适用于所有集合和数组) (推荐使用)注意：增强for只能操作集合和数组定义格式：for(数据类型 临时变量名 : 集合或者数组){ }例如定义了一个集合ArrayList list = new ArrayList(); 此处的集合如不指定数据类型，默认为Object类型，则它的增强for格式就为：for(Object obj：list) {}1234567891011//定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(10); arrayList.add(50); arrayList.add(\"你好\"); arrayList.add(8); //增强for进行遍历 for (Object object : arrayList) &#123; System.out.print(object + \" \"); &#125; 7.2 迭代器7.2.1 何为迭代器 迭代器是从集合中取出元素的一种标准方式，我们取出任何集合中的元素都可以按照这个标准来获取，主要遍历Collection集合中的元素。迭代是取出集合中元素的一种方式 7.2.2 原理 因为多种集合的数据结构不同，所以存储方式不同，因此取出方式也不同。这个时候，我们就把判断和获取功能定义在了一个接口中，将来，遍历哪种集合的时候，只要该集合内部实现这个接口即可(由于集合内部已经实现了该接口，因此直接使用即可，无需我们手动实现 ) 7.2.3 使用方式 通过集合对象调用iterator()方法便可获得一个且迭代器对象Iterator，然后再通过hasNext()方法判断是否含有元素，最后通过next()方法获取集合中的元素。（使用示例见上文7.1集合遍历中的第三种方法） 7.2.4 常见问题在我们对集合进行遍历的时候，有时候可能会对集合进行删除或者增加元素。但当我们使用Iterator对集合进行遍历的同时进行增删操作时，会出现一个异常，那就是并发修改异常 ConcurrentModificationException。 但要是我们硬是要在迭代的时候对元素进行增删操作的时候该肿么办呢？这时就有一个办法解决啦！这个办法就是通过集合对象获取Iterator的子接口ListIterator (例如：ListIterator iterator = arrayList.listIterator(); )7.2.5 Iterator 和 ListIterator的区别 1、Iterator是ListIterator的父接口 2、Iterator是Collection集合的公共的取出容器中元素的方式，对于List，Set都通用。而ListIterator是List集合的特有的取出元素的方式 3、Iterator中只具备hasNext(),next(),remove()方法，可以删除被遍历到的元素ListIterator中具备对遍历到的元素进行增(add)删(remove)改(set)查(next)的方法，可以对元素逆向遍历previouse相对于next,hasPreviouse相对于hasNext(用的很少) 7.2.6 Iterator 和 ListIterator的成员方法 8. LinkedListLinkedList底层实现是链式结构，它的特点是增加删除元素快，查询元素慢。就像人们手牵手连在一起排成一条队列，每个人就可以看做一个元素，当有一个人想进入或者退出队列的时候，只是旁边两人断开手就行了，要是想查询某人处于什么位置，只能从开头或者默认一个一个地查询下去，这样效率就大大下降了。8.1 特有的方法8.2 使用示例12345678910111213141516171819202122import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); list.addFirst(\"java01\"); list.addFirst(\"java02\"); list.addFirst(\"java03\"); list.addFirst(\"java04\"); System.out.println(list); System.out.println(list.getFirst()); while (!list.isEmpty()) &#123; System.out.println(list.removeLast()); &#125; &#125;&#125; 9. 泛型9.1 何为泛型 泛型是一种把明确类型的工作放在了创建对象或者调用方法时候才去明确的特殊的类型，泛型就相当于一个预定义类型 9.2 好处 把系统运行期间的异常提前到了编译期间，提高了安全性 优化了程序设计，不需要再做强壮了 9.3 缺点泛型只能传入引用类型，不能传入基本类型，如需要传入基本类型只能传入基本类型对应的包装类类型包装类表如下：9.4 泛型的使用泛型可以定义在类中，方法中和接口中。下面介绍在创建对象时使用泛型和不使用泛型的区别。不使用泛型时：1234567891011//定义一个ArrayList集合，没有指定泛型，默认为Object类型 ArrayList arrayList = new ArrayList(); arrayList.add(\"元素1\"); arrayList.add(\"元素2\"); arrayList.add(\"元素3\"); for (int i = 0; i &lt; arrayList.size(); i++) &#123; //由于ArrayList默认为Object类型，因此在不加泛型的时候获取元素需要强转 String string = (String) arrayList.get(i); System.out.print(string + \" \"); &#125; 使用泛型：123456789101112//定义一个ArrayList集合,指定泛型为String类型 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(\"元素1\"); arrayList.add(\"元素2\"); arrayList.add(\"元素3\"); //arrayList.add(2); 这里如果添加非String类型，会报错，因为已经指定泛型,从而将运行期间的异常提前到了编译期间 for (int i = 0; i &lt; arrayList.size(); i++) &#123; //由于在创建集合对象时已经给定泛型，因此在此不需要强转 String string = arrayList.get(i); System.out.print(string + \" \"); &#125; 10. ArrayList练习需求：ArrayList去除集合中字符串的重复值(字符串的内容相同) 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.Iterator;/** * 思路：想要对集合中的元素进去重，可以创建一个新的集合，然后再遍历的时候判断新集合是否包含某个元素。如果有了就不添加，否则就添加到新集合里面，最终得到的新集合就是没有重复元素的集合。 */public class Demo &#123; public static void main(String[] args) &#123; //定义一个ArrayList集合 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); //往集合中添加数据 arrayList.add(\"aa\"); arrayList.add(\"cc\"); arrayList.add(\"aa\"); arrayList.add(\"bb\"); arrayList.add(\"aa\"); Iterator&lt;String&gt; iterator = arrayList.iterator(); //获取迭代器 ArrayList&lt;String&gt; newList = new ArrayList&lt;&gt;(); //创建一个新的集合 while (iterator.hasNext()) &#123; String string = iterator.next(); //获取就集合中的每个元素 if (!newList.contains(string)) &#123; //如果新集合不包含该元素，就添加到新集合中 newList.add(string); &#125; &#125; System.out.println(newList); //输出结果：[aa, cc, bb] &#125;&#125; 11. HashSet集合HashSet集合存储的元素不会重复，并且存储顺序是不一致的。那么HashSet集合在添加元素时是如何保证元素不会重复添加呢？其实它是通过两个方法来进行判断的。11.1 保证不重复添加元素 hashCode()方法：首先通过调用对象的hashCode() 方法，返回一个int型的数据，这个数据就是哈希值。当存储两个元素时，会判断这两个元素的哈希值是否相同，如果不相同，就添加到集合中；否则会进行调用equals()方法 equals()方法：当两个元素的元素哈希值相等时，会调用此方法来判断两者的内容是否相同。不同则添加，相同就不添加到集合中 注意：如果两个元素的哈希值不同，就不再需要调用equals方法了。123456789101112131415161718192021public class Demo &#123; public static void main(String[] args) &#123; //1.创建一个HashSet集合,并指定为String泛型 HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); //往集合中添加元素 hashSet.add(\"aa\"); hashSet.add(\"bb\"); hashSet.add(\"aa\"); //添加重复元素 hashSet.add(\"cc\"); //获取hashSet的迭代器对象 Iterator&lt;String&gt; iterator = hashSet.iterator(); //对元素进行遍历 while (iterator.hasNext()) &#123; String string = iterator.next(); System.out.print(string + \" \"); //输出：aa bb cc &#125; &#125;&#125; 11.2 HashSet主要方法通过API可以看出HashSet的主要方法有： 11.3 HashSet存储自定义对象 需求：往HashSet集合中存储Person对象，如果姓名和年龄相同，视为同一个人。 首先定义一个Person实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 定义一个Person实体类(这里面的方法都是同快捷键生成的 Alt+Shift+S) * 必须重写hashCode()方法和equals()方法，不然在添加对象进集合的时候不会去重 */public class Person &#123; /** 姓名*/ private String name; /** 年龄*/ private int age; /** 无参构造方法*/ public Person() &#123; super(); &#125; /** 有参构造方法*/ public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /** * 重写hashCode()方法 */ @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; /** * 重写equals()方法 */ @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; &#125; 然后再创建一个集合存储元素，并遍历1234567891011121314151617181920212223242526272829public class HashSetTest &#123; public static void main(String[] args) &#123; //创建一个集合，并只能存储Person对象 HashSet&lt;Person&gt; hs = new HashSet&lt;&gt;(); //往集合中添加了6个元素，有重复 hs.add(new Person(\"张三\", 23)); hs.add(new Person(\"李四\", 24)); hs.add(new Person(\"张三\", 23)); hs.add(new Person(\"王五\", 25)); hs.add(new Person(\"周六\", 26)); hs.add(new Person(\"李四\", 24)); //获取迭代器对象对集合进行遍历 Iterator&lt;Person&gt; iterator = hs.iterator(); while (iterator.hasNext()) &#123; Person person = iterator.next(); System.out.println(\"姓名：\"+person.getName()+\",年龄：\"+person.getAge()); &#125; &#125; /* 输出： 姓名：周六,年龄：26 姓名：张三,年龄：23 姓名：李四,年龄：24 姓名：王五,年龄：25 */&#125; 小结：如果想实现HashSet集合存储不重复自定义对象，那么让自定义对象重写hashCode()方法和equals()方法即可。 12. TreeSet集合TreeSet集合存储元素也是不重复的，它的原理是底层使用二叉树(也可称为红黑树)结构，根据树的节点进行存储和取出。那么何为二叉树结构呢？ 将TreeSet集合中存储的第一个元素作为根节点，再进行添加元素的时候，如果比根节点小，就排在根节点的左边，否则就在根节点的右边，相同就不进行任何操作。以此不断进行比较(小的往左，大的往右) 下面是二叉树的一张图，有助于理解(图片源于网络，侵删) 12.1 TreeSet常用的方法 12.2 TreeSet对对象进行排序TreeSet对元素支持自然排序和自定义排序两种排序方式，下面介绍自定义对象排序的两种方式需求：对一个Person对象实现按年龄从大到小排序 方式一：自定义的对象类实现Comparable接口，重写compareTo()方法 自定义对象类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 定义一个Person实体类,实现Comparable接口，重写compareTo()方法 */public class Person implements Comparable&lt;Person&gt; &#123; /** 姓名*/ private String name; /** 年龄*/ private int age; /** 无参构造方法*/ public Person() &#123; super(); &#125; /** 有参构造方法*/ public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /** * 重写compareTo方法，定义排序规则 */ @Override public int compareTo(Person o) &#123; //使用三元运算，当年龄相同时不对Person对象去重 int num = this.age - o.age; //当num==0时，说明年龄相同.升序排序 //int num = 0.age - this.age; //降序排序 return num == 0 ? 1:num; &#125; &#125; 测试类：1234567891011121314151617181920212223242526public class TreeSetTest &#123; public static void main(String[] args) &#123; //创建一个TreeSet集合 TreeSet&lt;Person&gt; ts = new TreeSet&lt;&gt;(); ts.add(new Person(\"张三\", 23)); ts.add(new Person(\"周六\", 26)); ts.add(new Person(\"王五\", 24)); ts.add(new Person(\"李四\", 24)); //获取迭代器对象 Iterator&lt;Person&gt; iterator = ts.iterator(); while (iterator.hasNext()) &#123; Person person = iterator.next(); System.out.println(\"姓名：\"+person.getName()+\"，年龄：\"+person.getAge()); &#125; &#125; /* 输出： 姓名：张三，年龄：23 姓名：王五，年龄：24 姓名：李四，年龄：24 姓名：周六，年龄：26 */&#125; 方式二：在创建TreeSet集合的时候传入一个比较器(Comparator的子类对象)，在比较器中对自定义对象定义排序规则 自定义对象类(没有实现Comparable接口)1234567891011121314151617181920212223242526272829303132333435363738/** * 定义一个Person实体类 */public class Person &#123; /** 姓名*/ private String name; /** 年龄*/ private int age; /** 无参构造方法*/ public Person() &#123; super(); &#125; /** 有参构造方法*/ public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 测试类：12345678910111213141516171819202122232425262728293031323334353637public class TreeSetTest &#123; public static void main(String[] args) &#123; //创建一个TreeSet集合，并传入一个比较器Comparator，并指定泛型 TreeSet&lt;Person&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; //判断年龄是否相等 int num = o1.getAge() - o2.getAge(); //按年龄升序排序 //int num = o2.getAge() - o1.getAge(); //按年龄降序排序 return num == 0 ? 1 :num; &#125; &#125;); //往集合中添加数据 ts.add(new Person(\"张三\", 23)); ts.add(new Person(\"周六\", 26)); ts.add(new Person(\"王五\", 24)); ts.add(new Person(\"李四\", 24)); //获取迭代器对象 Iterator&lt;Person&gt; iterator = ts.iterator(); while (iterator.hasNext()) &#123; Person person = iterator.next(); System.out.println(\"姓名：\"+person.getName()+\"，年龄：\"+person.getAge()); &#125; &#125; /* 输出： 姓名：张三，年龄：23 姓名：王五，年龄：24 姓名：李四，年龄：24 姓名：周六，年龄：26 */&#125; 小结：在TreeSet中使存储的自定义对象实现排序。一：在自定义对象类中实现Comparable接口，并重写它的compareTo方法二：在创建TreeSet集合的时候，传入一个比较器Comparator,并重写它的compare()方法注意：基本数据类型和引用数据类型进行比较的时候是不一样的，同时两者在比较之后得到的结果都是一个int类型的数据，当这个数据等于0的时候，说明比较结果相同，可以用三元运算符返回1(1代表返回对象本身，如不返回1，TreeSet会认为集合已经包含该元素，就不会添加该元素了) (基本数据类型) 升序: this.age - p.age 降序: p.age - this.age (引用数据类型)升序:this.name.CompareTo(o.name);降序:o.name.CompareTo(this.name); 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"Java基础","slug":"JavaBase","permalink":"http://hunterblog.cn/tags/JavaBase/"},{"name":"Java","slug":"Java","permalink":"http://hunterblog.cn/tags/Java/"}]},{"title":"MySQL的安装和配置","date":"2017-03-02T06:44:45.000Z","path":"2017/03/02/MySql-install.html","text":"前言：本文将以MySQL5.5作为示例(32位和64位的安装是一样的，具体请根据自己的电脑版本选择)这里有一个32位和64位MySQL的安装包，有需要的同学可以自取。 链接：http://pan.baidu.com/s/1hsDmC88 密码：txxd 一、MySQL的安装1.打开下载的文件，双击mysql-5.5.40-win64.msi，点击“Next”2.选中协议，继续点击“Next”3.选择安装类型，有“Typical（默认）”、“Complete（完全）”、“Custom（用户自定义）”三个选项。选择“Custom”4.在“Developer Components（开发者部分）”上左键单击，选择“This feature,and all subfeatures, will be installed on local hard drive.”，即“此部分，及下属子部分内容，全部安装在本地硬盘上”。在上面的“MySQL Server（mysql服务器）”、“Client Programs（mysql客户端程序）”、“Documentation（文档）”也如此操作，以保证安装所有文件。点选“Change…”，手动指定安装目录即可。5.确认先前的设置是否有误，有误就按“Back”返回重做，确认无误就按“Install”继续安装在这过程中会出现两个成功安装的界面，点击“Next”即可6.将“Launch the MySQL Instance Configuration Wizard”选中，这里主要是询问是否继续配置MySQL数据的参数，勾选上，然后点击”Finish” 二、MySQL参数的配置1.MySQL配置向导界面，点击“Next”2.选择配置方式：“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）”，本文选择“Detailed Configuration”，方便熟悉配置过程3.选择服务器类型：“Developer Machine（开发测试类，mysql占用很少资源）”、“Server Machine（服务器类型，mysql占用较多资源）”、“Dedicated MySQL Server Machine（专门的数据库服务器，mysql占用所有可用资源）” ，选择“Developer Machine”类型后，点击“Next”4.选择MySQL数据库的大致用途：“Multifunctional Database（通用多功能型，好）”、“Transactional Database Only（服务器类型，专注于事务处理，一般）”、“Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional），选择“Multifunctional Database”，点击“Next”继续5.表空间设置，选择“Installation Path即可”，点击“Next”继续6.选择网络并发连接数(同时连接的数目)，“Decision Support(DSS)/OLAP（20个左右）”、“Online Transaction Processing(OLTP)（500个左右）”、“Manual Setting（手动设置）”，选择“Manual Setting”，点击“Next”继续7.是否启用TCP/IP链接，设定端口。如果不启用，就只能在自己的机器上访问mysql数据库，在这个页面上，您还可以选择“启用标准模式”（Enable Strict Mode），这样MySQL就不会允许细小的语法错误。如果是新手，建议您取消标准模式以减少麻烦。但熟悉MySQL以后，尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性，本文选择勾选上。按“Next”继续8.对MySQL默认数据库语言编码进行设置(重要)。选择第二个，然后将下面的“Character Set”设置为“utf-8”，点击“Next”继续安装9.是否将MySQL安装为Windows服务。还可以指定Service Name（服务标识名称），是否将mysql的bin目录加入到Windows PATH（加入后，就可以直接使用bin下的文件，而不用指出目录名，不用指出mysql.exe的完整地址，很方便），我这里全部打上了勾，Service Name不变。按“Next”继续。10.是否修改默认root用户的密码。“Enable root access from remote machines（是否允许root用户在其它的机器上登陆，如果要安全，就不要勾上，如果要方便，就勾上它）”。最后“Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询）”，一般就不用勾了，设置完毕，按“Next”继续11.确认设置无误后，按“Execute”使设置生效，这时需要等待一小会，待图中4个框都打上勾了，即完成MYSQL的安装和配置12.最后可以验证一下是否安装成功，打开命令行，输入“mysql -u root -p”，点击回车，输入密码，如果出现一下信息则说明安装配置成功，尽情享受数据库之旅吧！ 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"MySQL数据库","slug":"MySQL","permalink":"http://hunterblog.cn/tags/MySQL/"}]},{"title":"Eclipse常用快捷键以及设置","date":"2017-02-27T11:44:32.000Z","path":"2017/02/27/EclipseForUse.html","text":"前言：Eclipse作为一个常用的开发工具，其功能也比较强大，要想在Eclipse中快速高效地进行开发，使用快捷键能使我们在开发中达到事半功倍的效果，下面将介绍关于Eclipse的一些常用的快捷键以及一些常见设置，希望能帮助到各位Coder。 常用快捷键：Alt + /：内容补全键，功能很强悍，当不记得全类名、方法名或属性名时使用这个即可提示，也是最常用的一个快捷键。(有一个设置能够替代内容补全键，能边输入边联想，下面设置中将介绍到) Ctrl + /：添加或取消单行注释 Ctrl + Shift + /：选中多行，即可添加多行注释 Ctrl + Shift + /：在多行注释的区域内，可取消多行注释 Ctrl + Shift + ↑或↓：快速复制所选中的代码(注意：此快捷键可能和Windows中的屏幕反转功能冲突，禁用Windows屏幕反转功能才可使用) Alt + ↑或↓：向上或向下移动所选择的代码 Ctrl + Shift + F：格式化代码(当代码写的很乱时，这个快捷键可以将代码的按照标准得格式显示) Ctrl + Shift + O：快速导入包 Alt + Shift + M：将选中的代码抽取成为一个方法 Ctrl + F：查找 Ctrl + D：删除选中行 Ctrl + 1 ：快速修复(最常用的快捷键之一。当代码下方出现小红线时，此快捷键可以提示多种情况进行修复，根据具体情况选择) Ctrl + W关闭当前编辑框 Ctrl + 2,L：自动补全代码(使用方式是先按Ctrl+2，然后个1秒左右再按L键即可) Alt + Shift + R：重命名(需要对项目名、包名、类名、变量名、方法名等进行修改时，建议使用此快捷键，避免发生不必要的错误) Alt + Shift + Z：对异常进行捕获 Alt + Shift + S + C：生成实体类的无参构造方法 Alt + Shift + S + O：生成实体类的有参构造方法(可根据实际情况选择参数，一般是select All) Alt + Shift + S + R：生成实体类的Getters和Setters方法 Alt + Shift + S + S：生成实体类的toString()方法 Alt + Shift + S + H：生成实体类的hashCode()和equals()方法 以上为Eclipse在开发中一些常用的快捷键，下面介绍一些常见的设置 常见设置1.如何显示行号在代码的最左侧前面，点击鼠标右键，选择 –&gt; Show Line Numbers即可显示行号。(想取消显示行号就再次选择即可) 2.如何修改字体大小及字体风格a：修改Java代码区域的字体大小及风格：window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Java –&gt; Java Edit Text Font –&gt; editb：修改控制台( Console)的字体及风格window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Debug –&gt; Console font –&gt; editc：修改全部的字体及风格(包括Java代码和控制台)window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Basic –&gt; Text Font –&gt; edit 3.切换工作空间(Workspace)File –&gt; Switch Workspace –&gt; Other 4.导入Java项目File –&gt;Import –&gt; General –&gt; Existing Progects into Workspace 5.取消悬浮提示(将鼠标停留在某个类上所出现的提示信息)window –&gt; Preferences –&gt; Java –&gt; Editor –&gt; Hovers。右边将Combined Hover勾去掉(这样代码的悬浮框就不会自动出现了。如果想看提示，将光标悬浮在代码上，按F2即可) 6.断点调试(重要)首先何为断点调试呢？断点调试就是在某区域的代码中加上开始断点和结束断点，然后等开始执行断点调试就可以看到代码是如何一步一步地执行下去的。那么我们如何使用断点调试呢？ a：添加断点在执行代码区域的左边双击就可出现一个小蓝点作为开始断点，然后又在结束调试的代码左边双击出现一个小蓝点作为结束断点(注意不要在注释上面作断点) b：使用断点调试在Java代码区域点击鼠标右键 –&gt; Debug As –&gt; Java Application(这是可能会弹出一个对话框，询问是否打开调试界面，点击yes即可)调试界面如下： c：如何一步一步执行呢点击F6即可执行下一步(淡绿色的代码块就是下一步将要执行的代码) d：停止调试点击上图出现的红色的正方形即可停止调试 7.代码自动联想功能(边输入边提示)Window –&gt; Preferences –&gt; Java –&gt; Content Assist在Content Assist这个界面下面有一个Auto activation triggers for Java，在其后面的框中添加.abcdefghijklmnopqrstuvwxyz即可实现自动联想功能。","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hunterblog.cn/tags/Eclipse/"},{"name":"IDE","slug":"IDE","permalink":"http://hunterblog.cn/tags/IDE/"}]},{"title":"JavaSe之面向对象","date":"2017-02-24T14:26:33.000Z","path":"2017/02/24/JavaSe.html","text":"前言：此文主要讲述何为面向对象、面向对象的三大特征、抽象类和接口，但只作简单的阐述，不深入研究 何为面向对象俗话说万物皆对象，每一个事物都可看作为一个对象，对象就拥有它的属性和功能(也称行为)，比如说一名学生，他的属性就有姓名，年龄，学号，体重，身高……等，功能(行为)有学习，吃饭，睡觉……等。Java中将这些对象抽象为每一个类，然后再对这些类进行一些相应的操作。创建对象的格式是： 类名 对象名 = new 类名(); 面向对象的三大思想特征：封装，继承，多态1. 封装1.1 定义：指隐藏对象的属性和实现细节，仅对外提供公共的访问方式（换句话说就是将属性私有化，并提供共有的方法访问） 1.2 private关键字可用于修饰成员内容，包括成员变量和成员方法，被他修饰完毕后的内容，在其他类中是不能直接访问的，换句话说就是被private修饰的内容只能在本类中使用 1.3 getter/setter方法的使用因为类的属性被私有化，只能在本类中访问，其他类想要访问就需要提供getter方法和setter方法。但这两个方法时相互独立的，不一定必须出现（get方法和set方法的名字可以随便起，只不过大家通过方法访问私有属性的时候形成了一个默认的规则：设置类的属性值通过setXxx()方法，获取类的属性通过getXxx()方法）。 1.4 this关键字a.this关键字只能代表本类对象b.this关键字代表所属方法的所属对象c.谁调用this，this就代表谁d.this可用于区分成员变量和局部变量同名的情况（例如this.属性名代表的是成员变量） 1.5 构造方法1.5.1 特点：a.方法名必须和类名保持一致b.没有返回值类型并且没有具体的返回值，连void都没有 1.5.2 作用：给对象的属性进行初始化 1.5.3 注意事项a.如果没有明确给出构造方法，系统会默认给出一个无参的构造方法b.只要给出明确的构造方法，系统将不会提供任何的构造方法c.构造方法的重载体现在参数的不同（包括参数类型、个数以及顺序） 1.6 给私有属性赋值的方式a.通过set方法（推荐使用）b.通过构造方法c.在定义成员变量的时候就赋值例如：private String name = “张三”；d.通过反射中的Fied类中的对象给对象的属性赋值 1.7构造方法和setter方法的区别a.构造方法是在创建对象的时候赋值，只能赋值一次b.setter方法是在创建完对象以后再给对象的属性赋值，能赋值多次 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 一个类的代码分布图： 属性 构造方法 成员方法 get方法和set方法 */public class Student &#123; /** 姓名 */ private String name; /** 年龄 */ private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; /** * 获取姓名 * * @return name 姓名 */ public String getName() &#123; return name; &#125; /** * 设置姓名 * * @param name * 姓名 */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取年龄 * * @return age 年龄 */ public int getAge() &#123; return age; &#125; /** * 设置年龄 * * @param age * 年龄 */ public void setAge(int age) &#123; this.age = age; &#125;&#125;测试类public class Test &#123; public static void main(String[] args) &#123; //通过无参构造创建对象，并给成员变量赋值 Student zs = new Student(); zs.setName(\"张三\"); zs.setAge(13); //通过有参构造创建对象，并给成员变量赋值 Student ls = new Student(\"李四\",14); //调用对象的方法 System.out.println(zs.getName()+\"----\"+zs.getAge()); System.out.println(ls.getName()+\"----\"+ls.getAge()); &#125;&#125; 1.8 static关键字1.8.1 定义static意为静态，可以修饰成员变量和成员方法，被static修饰的成员，可以被该类下的所有对象共享（例如 private static int number = 10; 这个number变量就可以被该类下所有对象使用） 1.8.2特点a.被static修饰的成员随着类的加载而加载， 并且优先于对象而存在（即在内存中加载完该成员才到对象的创建）b.可以通过类名.直接调用c.被该类下所有对象共享 1.8.3注意事项a.在静态方法中没有this关键字，因为静态是随着类的加载而加载，而this关键字是对象创建才存在的b.静态方法只能访问静态成员变量和静态的方法（即静态只能访问静态）c.静态内容可以通过创建对象调用，也可以直接通过类名.调用。（推荐通过类名点调用） 2.继承2.1由来和定义a.在多个类中存在相同的属性和行为时，将这些内容抽取到单个类中，那么多个类无需再定义该属性和行为，只需要继承那单个类即可b.多个类成为子类或派生类，单个类成为超类或者父类又或者基类 2.2好处和弊端a.提高代码的复用性b.使类与类产生关系，是多态的前提c.Java中只支持单继承，不支持多继承，但支持多层继承 2.3使用场景子类是父类的一种，比如猫继承动物，猫就是子类，动物就是父类（注意：不要为了获取某个功能而去继承） 2.4this和super比较2.4.1概念上的区别super代表的是父类内存空间标识this代表所在方法所属对象的引用 2.4.2super使用场景a.当子父类中出现同名成员可以用super区分b.子类调用父类的构造方法可以用super.方法名调用 2.4.3注意事项a.构造方法中的this()和super()语句必须放在第一行，并且只能取其一b.如果父类中无无参构造，子类只能通过super(参数)调用父类的构造方法，通过this(…)调用本类的构造方法 2.5重写OverRide和重载OverLoad2.5.1重写OverRide在子父类关系中，子类中存在与父类中方法声明完全一样的方法叫重写（即除了方法体不一样，其他都是一样的，但子类的权限要大于等于父类的） 2.5.2重载OverLoad在一个类中或者在子父类中存在多个同名方法，并且参数列表不同的方法叫重载 2.5.3注意事项a.只有方法才存在重写，变量不存在重写这一说法b.父类中的私有方法不能被覆盖 2.6final关键字2.6.1定义很多时候有些方法内容时不能被重写的。而我们知道父类方法声明为public就可以被重写。针对这种情况，我们可以做个标记，告诉别人此类不能被重写final ：最终的意思，可以修饰类，变量以及成员方法 2.6.2被final修饰的特点a.被final修饰的方法不能被重写b.被final修饰的类不能被继承c.被final修饰的变量其实就是常量，必须显示地赋值，并且命名要全部大写，每个单词之间用下划线连接起来 2.6.3被final修饰的类java.lang.reflect.Array boolean的包装类java.lang.Boolean byte的包装类java.lang.Byte char的包装类java.lang.Character double的包装类java.lang.Double float的包装类java.lang.Float int的包装类java.lang.Integer long的包装类java.lang.Long short的包装类java.lang.Short void的包装类java.lang.Void String类java.lang.String System类java.lang.System Class类java.lang.Class&lt;T&gt; 编译器java.lang.Compiler类 Math类java.lang.Math 两个可变字符序列类java.lang.StringBuffer与java.lang.StringBuilder Scanner类java.util.Scanner 正则匹配器java.util.regex.Matcher 正则表达式编译形式类java.util.regex.Pattern 3.多态3.1多态的定义对象在不同时刻表现出来的不同状态 3.2多态的前提条件a.要有继承关系或者实现关系b.要有方法重写或者实现关系c.要有父类引用指向子类对象或者父类接口指向子类对象 3.3多态的成员特点3.3.1成员变量编译看等号左边，运行看等号左边12Fu fu = new Zi();System.out.println(fu.name);//调用的是父类的name属性 3.3.2成员方法编译看等号的左边，运行看等号的右边12Fu fu = new Zi();fu.show();//调用的是子类的show() 小结：方法运行看右边 3.4多态的好处和弊端3.4.1弊端父类引用不能直接使用子类对象的特有功能，只能通过向下转型（强转）实现 3.4.2好处增强了程序的拓展性和可维护性，大大减少了维护成本 拓展抽象类1.由来类里面封装的是相关的属性和行为，但是有些行为我们是不确定做什么的，这个时候我们就把这个方法用abstract修饰，当方法被这个关键字修饰以后，就不能有方法体了，并且这个类也必须被abstract修饰，这就是抽象类的由来 2.定义如果一个类中含有抽象方法，这个类就可以被称为抽象类，该类也需要被abstract修饰。它的作用是强制要求子类必须实现某些功能（抽象方法：只有方法声明，没有方法体，被abstract修饰） 3.格式123456789101112131415161718//定义抽象类的格式 abstract class Animal&#123; abstract void eat(); public void run()&#123; System.out.println(\"我在跑步\"); &#125; &#125; //使用格式1 //定义个普通类，继承抽象类，必须实现抽象类中的抽象方法 class Dog extends Animal&#123; void eat()&#123; System.out.println(\"狗吃骨头\"); &#125; &#125; //使用格式2 //定义一个抽象类继承抽象类，不是必须要实现父类的抽象方法 abstract class Cat extends Animal&#123; &#125; 4.基本特点a. 抽象方法和抽象类用关键字abstract表示。b. 有抽象方法的类一定是抽象类(或者接口)。抽象类中不一定有抽象方法。c. 抽象类不能被实例化。d. 如果一个类继承抽象类，那么这个类要么本身也是抽象类。这个类 必须重写父类的所有抽象方法。 5.成员特点5.1 成员变量可以有成员变量，也可以有常量 5.2 构造方法抽象类有构造方法，但是不能通过构造方法创建对象，构造方法的作用是让子类访问父类数据之前，对父类数据进行初始化 5.3成员方法可以有抽象方法，也可以有非抽象方法抽象方法是为了要求子类做某些事情非抽象方法是为了提高代码的复用性，被子类继承 6.使用场景 人刚生下来就具备哭的行为特征，但是每个人哭的行为不一样，所以人应该定义为抽象类，这些与生俱来的属性和行为应该定义在类里面 接口1.定义我们可以把接口看成是一种特殊的抽象类。比抽象类更抽象。因为它里面的方法都是抽象的。但是注意，接口不是类，我们只是把他看成类 2.格式1234567891011121314151617//定义格式 interface 接口名 &#123; //静态常量和抽象方法 &#125; //使用格式 //一个类实现一个接口 class 类名 implements 接口名1，接口名2... &#123; //覆盖接口中的全部方法 &#125; //一个抽象类实现一个接口，不必重写接口中的抽象方法 abstract class 类名 extends Object implements 接口1, 接口2,接口..... &#123; //方法体不需要全部都覆盖 &#125; //一个接口继承一个接口 interface 接口名 extends 接口1，接口2.. &#123; &#125; 3.基本特点a. 接口不能被实例化b. 接口中的方法要么被子类重写，要么子类也是抽象类 4.成员特点4.1 成员变量接口中只有常量。因为接口中的成员变量有默认的修饰符：public static final 4.2构造方法接口没有构造方法。因为接口中的成员变量都被final修饰，定义的时候必须做初始化 4.3成员方法接口中的方法都是抽象方法，没有方法体。因为接口中的成员方法有默认修饰符public abstract 5.思想特点a. 接口是对外暴露的规则b. 接口是程序的功能拓展c. 接口的出现降低耦合性d. 接口可以用来多实现 6.使用场景随着人的年纪的增加，会学习舞蹈，吉他，这些都是后天培养的拓展的功能，所以应该把学习跳舞和学习吉他定义为接口，这些后天学习的拓展功能应该定义在接口里 抽象类和接口相同点：都是不断向上抽取而来不同点：a.抽象类需要被继承，而且只能单继承 接口需要被实现，而且可以多实现 b.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法 接口中只能定义抽象方法，必须有子类实现 c.抽象类的字段默认是friendly 接口的字段默认是public static final 下面是抽象类与接口的具体使用： 类、抽象类与接口三者之间的继承与实现关系： 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"Java","slug":"Java","permalink":"http://hunterblog.cn/tags/Java/"},{"name":"JavaBase","slug":"JavaBase","permalink":"http://hunterblog.cn/tags/JavaBase/"}]}]