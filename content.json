[{"title":"JavaSe之集合（一）","date":"2017-03-09T10:07:13.000Z","path":"2017/03/09/JavaSe-Collection/","text":"1. 集合概述由于我们开发过程中，难以避免不去操作数据，操作对象就有可能对数据进行存储，存储数据的方式多种多样，之前我们都是将数据存储在数组中，但数组的特点是长度固定不可改变的，这样就不适合用于存储变化(个数的变化)的数据。因此，Java提供一种容器用于存储数据，这个容器就叫做集合。 前言：本文主要介绍Collection根接口(也被成为单列集合)下常用集合的特点和使用方法 2. 集合和数组的区别数组： 长度固定 可以存储基本数据类型，也可以存储引用数据类型 存储的数据类型必须要一致(比如说创建一个int类型的数组，它就只能存整数，不能存double或者String类型等) 集合： 长度可变 只能存储引用数据类型 可以存储不同类型的对象。(可以存int、String、double等) 3. 集合的体系： 4.下面看一下各成员特点|- - List：有序(序指的是存和取得顺序一致，怎么样存就怎么样取)，元素可以重复|- - - - - - - ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高|- - - - - - - Vector：底层数据结构是数组，查询快，增删慢，线程安全，效率低|- - - - - - - LinkedList：底层数据结构是链表，查询慢，增删快，线程不安全，效率高 |- - Set：无序，元素不可以重复|- - - - - - - HashSet：底层数据结构是哈希表，县城不安全，效率高|- - - - - - - TreeSet：底层数据结构是二叉树，线程不安全，效率高 5. Collection接口中的常用方法注：Collection是一个根接口，继承它的子类或者子接口都能使用它的方法 6. List集合特有的方法 7. ArrayListArrayList是List接口下的一个实现类之一，也是最常用的一个集合，由于它的底层是数组结构实现的，因此可以看成是一个长度可变的数组，下面介绍关于ArrayList的常见使用123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; //定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(\"你好\"); //添加元素 arrayList.add(20); arrayList.add(20); //添加了重复元素 arrayList.set(0, \"hello\"); //修改了索引为0的元素 int size = arrayList.size(); //获取集合的大小 System.out.println(\"集合的大小为：\"+size); //输出：集合的大小为：3 System.out.println(arrayList.get(2)); //输出：20 System.out.println(arrayList); //输出：[hello, 20, 20] &#125; &#125; 7.1 集合的遍历1.通过集合转数组，然后再对数组进行遍历12345678910Collection c = new ArrayList(); c.add(\"abc\"); c.add(\"abcd\"); c.add(\"abcde\"); Object[] array = c.toArray(); //将集合转为数组 for(int i=0; i&lt;array.length; i++)&#123; //遍历输出 String str = (String)array[i]; System.out.println(str.toUpperCase());&#125; 2.通过get()和size()方法结合(仅仅适用于Collection的子接口List接口)1234567891011//定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(10); arrayList.add(50); arrayList.add(\"你好\"); arrayList.add(8); for (int i = 0; i &lt; arrayList.size(); i++) &#123; Object obj = arrayList.get(i); //根据索引获取值，在此返回的是Object数据类型 System.out.print(obj + \" \"); &#125; 3.通过迭代器实现(适用于所有集合) (下面将会介绍)12345678910111213141516//定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(10); arrayList.add(50); arrayList.add(\"你好\"); arrayList.add(8); //第一步：创建迭代器对象 Iterator iterator = arrayList.iterator(); //第二步：通过hasNext()方法判断迭代器中是否有元素 while (iterator.hasNext()) &#123; //第三步：通过next()方法获取元素 Object object = iterator.next(); System.out.print(object + \"\"); &#125;&#125; 4.通过增强for循环遍历(适用于所有集合和数组) (推荐使用)注意：增强for只能操作集合和数组定义格式：for(数据类型 临时变量名 : 集合或者数组){ }例如定义了一个集合ArrayList list = new ArrayList(); 此处的集合如不指定数据类型，默认为Object类型，则它的增强for格式就为：for(Object obj：list) {}1234567891011//定义一个ArrayList集合 ArrayList arrayList = new ArrayList(); arrayList.add(10); arrayList.add(50); arrayList.add(\"你好\"); arrayList.add(8); //增强for进行遍历 for (Object object : arrayList) &#123; System.out.print(object + \" \"); &#125; 7.2 迭代器7.2.1 何为迭代器 迭代器是从集合中取出元素的一种标准方式，我们取出任何集合中的元素都可以按照这个标准来获取，主要遍历Collection集合中的元素。迭代是取出集合中元素的一种方式 7.2.2 原理 因为多种集合的数据结构不同，所以存储方式不同，因此取出方式也不同。这个时候，我们就把判断和获取功能定义在了一个接口中，将来，遍历哪种集合的时候，只要该集合内部实现这个接口即可(由于集合内部已经实现了该接口，因此直接使用即可，无需我们手动实现 ) 7.2.3 使用方式 通过集合对象调用iterator()方法便可获得一个且迭代器对象Iterator，然后再通过hasNext()方法判断是否含有元素，最后通过next()方法获取集合中的元素。（使用示例见上文7.1集合遍历中的第三种方法） 7.2.4 常见问题在我们对集合进行遍历的时候，有时候可能会对集合进行删除或者增加元素。但当我们使用Iterator对集合进行遍历的同时进行增删操作时，会出现一个异常，那就是并发修改异常 ConcurrentModificationException。 但要是我们硬是要在迭代的时候对元素进行增删操作的时候该肿么办呢？这时就有一个办法解决啦！这个办法就是通过集合对象获取Iterator的子接口ListIterator (例如：ListIterator iterator = arrayList.listIterator(); )7.2.5 Iterator 和 ListIterator的区别 1、Iterator是ListIterator的父接口 2、Iterator是Collection集合的公共的取出容器中元素的方式，对于List，Set都通用。而ListIterator是List集合的特有的取出元素的方式 3、Iterator中只具备hasNext(),next(),remove()方法，可以删除被遍历到的元素ListIterator中具备对遍历到的元素进行增(add)删(remove)改(set)查(next)的方法，可以对元素逆向遍历previouse相对于next,hasPreviouse相对于hasNext(用的很少) 7.2.6 Iterator 和 ListIterator的成员方法 8. LinkedListLinkedList底层实现是链式结构，它的特点是增加删除元素快，查询元素慢。就像人们手牵手连在一起排成一条队列，每个人就可以看做一个元素，当有一个人想进入或者退出队列的时候，只是旁边两人断开手就行了，要是想查询某人处于什么位置，只能从开头或者默认一个一个地查询下去，这样效率就大大下降了。8.1 特有的方法8.2 使用示例12345678910111213141516171819202122import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); list.addFirst(\"java01\"); list.addFirst(\"java02\"); list.addFirst(\"java03\"); list.addFirst(\"java04\"); System.out.println(list); System.out.println(list.getFirst()); while (!list.isEmpty()) &#123; System.out.println(list.removeLast()); &#125; &#125;&#125; 9. 泛型9.1 何为泛型 泛型是一种把明确类型的工作放在了创建对象或者调用方法时候才去明确的特殊的类型，泛型就相当于一个预定义类型 9.2 好处 把系统运行期间的异常提前到了编译期间，提高了安全性 优化了程序设计，不需要再做强壮了 9.3 缺点泛型只能传入引用类型，不能传入基本类型，如需要传入基本类型只能传入基本类型对应的包装类类型包装类表如下：9.4 泛型的使用泛型可以定义在类中，方法中和接口中。下面介绍在创建对象时使用泛型和不使用泛型的区别。不使用泛型时：1234567891011//定义一个ArrayList集合，没有指定泛型，默认为Object类型 ArrayList arrayList = new ArrayList(); arrayList.add(\"元素1\"); arrayList.add(\"元素2\"); arrayList.add(\"元素3\"); for (int i = 0; i &lt; arrayList.size(); i++) &#123; //由于ArrayList默认为Object类型，因此在不加泛型的时候获取元素需要强转 String string = (String) arrayList.get(i); System.out.print(string + \" \"); &#125; 使用泛型：123456789101112//定义一个ArrayList集合,指定泛型为String类型 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(\"元素1\"); arrayList.add(\"元素2\"); arrayList.add(\"元素3\"); //arrayList.add(2); 这里如果添加非String类型，会报错，因为已经指定泛型,从而将运行期间的异常提前到了编译期间 for (int i = 0; i &lt; arrayList.size(); i++) &#123; //由于在创建集合对象时已经给定泛型，因此在此不需要强转 String string = arrayList.get(i); System.out.print(string + \" \"); &#125; 10. ArrayList练习需求：ArrayList去除集合中字符串的重复值(字符串的内容相同) 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.Iterator;/** * 思路：想要对集合中的元素进去重，可以创建一个新的集合，然后再遍历的时候判断新集合是否包含某个元素。如果有了就不添加，否则就添加到新集合里面，最终得到的新集合就是没有重复元素的集合。 */public class Demo &#123; public static void main(String[] args) &#123; //定义一个ArrayList集合 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); //往集合中添加数据 arrayList.add(\"aa\"); arrayList.add(\"cc\"); arrayList.add(\"aa\"); arrayList.add(\"bb\"); arrayList.add(\"aa\"); Iterator&lt;String&gt; iterator = arrayList.iterator(); //获取迭代器 ArrayList&lt;String&gt; newList = new ArrayList&lt;&gt;(); //创建一个新的集合 while (iterator.hasNext()) &#123; String string = iterator.next(); //获取就集合中的每个元素 if (!newList.contains(string)) &#123; //如果新集合不包含该元素，就添加到新集合中 newList.add(string); &#125; &#125; System.out.println(newList); //输出结果：[aa, cc, bb] &#125;&#125; ————————- 未完待续 ——————————","tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"http://hunterblog.cn/tags/JavaSe/"},{"name":"集合","slug":"集合","permalink":"http://hunterblog.cn/tags/集合/"}]},{"title":"MySQL的安装和配置","date":"2017-03-02T06:44:45.000Z","path":"2017/03/02/MySql-install/","text":"下面介绍MySQL的安装和配置 注：本文将以MySQL5.5作为示例(32位和64位的安装是一样的，具体请根据自己的电脑版本选择)这里有一个32位和64位MySQL的安装包，有需要的同学可以自取。链接：http://pan.baidu.com/s/1hsDmC88 密码：txxd 一、MySQL的安装1.打开下载的文件，双击mysql-5.5.40-win64.msi，点击“Next”2.选中协议，继续点击“Next”3.选择安装类型，有“Typical（默认）”、“Complete（完全）”、“Custom（用户自定义）”三个选项。选择“Custom”4.在“Developer Components（开发者部分）”上左键单击，选择“This feature,and all subfeatures, will be installed on local hard drive.”，即“此部分，及下属子部分内容，全部安装在本地硬盘上”。在上面的“MySQL Server（mysql服务器）”、“Client Programs（mysql客户端程序）”、“Documentation（文档）”也如此操作，以保证安装所有文件。点选“Change…”，手动指定安装目录即可。5.确认先前的设置是否有误，有误就按“Back”返回重做，确认无误就按“Install”继续安装在这过程中会出现两个成功安装的界面，点击“Next”即可6.将“Launch the MySQL Instance Configuration Wizard”选中，这里主要是询问是否继续配置MySQL数据的参数，勾选上，然后点击”Finish” 二、MySQL参数的配置1.MySQL配置向导界面，点击“Next”2.选择配置方式：“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）”，本文选择“Detailed Configuration”，方便熟悉配置过程3.选择服务器类型：“Developer Machine（开发测试类，mysql占用很少资源）”、“Server Machine（服务器类型，mysql占用较多资源）”、“Dedicated MySQL Server Machine（专门的数据库服务器，mysql占用所有可用资源）” ，选择“Developer Machine”类型后，点击“Next”4.选择MySQL数据库的大致用途：“Multifunctional Database（通用多功能型，好）”、“Transactional Database Only（服务器类型，专注于事务处理，一般）”、“Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional），选择“Multifunctional Database”，点击“Next”继续5.表空间设置，选择“Installation Path即可”，点击“Next”继续6.选择网络并发连接数(同时连接的数目)，“Decision Support(DSS)/OLAP（20个左右）”、“Online Transaction Processing(OLTP)（500个左右）”、“Manual Setting（手动设置）”，选择“Manual Setting”，点击“Next”继续7.是否启用TCP/IP链接，设定端口。如果不启用，就只能在自己的机器上访问mysql数据库，在这个页面上，您还可以选择“启用标准模式”（Enable Strict Mode），这样MySQL就不会允许细小的语法错误。如果是新手，建议您取消标准模式以减少麻烦。但熟悉MySQL以后，尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性，本文选择勾选上。按“Next”继续8.对MySQL默认数据库语言编码进行设置(重要)。选择第二个，然后将下面的“Character Set”设置为“utf-8”，点击“Next”继续安装9.是否将MySQL安装为Windows服务。还可以指定Service Name（服务标识名称），是否将mysql的bin目录加入到Windows PATH（加入后，就可以直接使用bin下的文件，而不用指出目录名，不用指出mysql.exe的完整地址，很方便），我这里全部打上了勾，Service Name不变。按“Next”继续。10.是否修改默认root用户的密码。“Enable root access from remote machines（是否允许root用户在其它的机器上登陆，如果要安全，就不要勾上，如果要方便，就勾上它）”。最后“Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询）”，一般就不用勾了，设置完毕，按“Next”继续11.确认设置无误后，按“Execute”使设置生效，这时需要等待一小会，待图中4个框都打上勾了，即完成MYSQL的安装和配置12.最后可以验证一下是否安装成功，打开命令行，输入“mysql -u root -p”，点击回车，输入密码，如果出现一下信息则说明安装配置成功，尽情享受数据库之旅吧！ 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://hunterblog.cn/tags/MySQL/"}]},{"title":"Eclipse常用快捷键以及常见设置","date":"2017-02-27T11:44:32.000Z","path":"2017/02/27/EclipseForUse/","text":"Eclipse作为一个常用的开发工具，其功能也比较强大，要想在Eclipse中快速高效地进行开发，使用快捷键能使我们在开发中达到事半功倍的效果，下面将介绍关于Eclipse的一些常用的快捷键以及一些常见设置，希望能帮助到各位Coder。 常用快捷键：Alt + /：内容补全键，功能很强悍，当不记得全类名、方法名或属性名时使用这个即可提示，也是最常用的一个快捷键。(有一个设置能够替代内容补全键，能边输入边联想，下面设置中将介绍到) Ctrl + /：添加或取消单行注释 Ctrl + Shift + /：选中多行，即可添加多行注释 Ctrl + Shift + /：在多行注释的区域内，可取消多行注释 Ctrl + Shift + ↑或↓：快速复制所选中的代码(注意：此快捷键可能和Windows中的屏幕反转功能冲突，禁用Windows屏幕反转功能才可使用) Alt + ↑或↓：向上或向下移动所选择的代码 Ctrl + Shift + F：格式化代码(当代码写的很乱时，这个快捷键可以将代码的按照标准得格式显示) Ctrl + Shift + O：快速导入包 Alt + Shift + M：将选中的代码抽取成为一个方法 Ctrl + F：查找 Ctrl + D：删除选中行 Ctrl + 1 ：快速修复(最常用的快捷键之一。当代码下方出现小红线时，此快捷键可以提示多种情况进行修复，根据具体情况选择) Ctrl + W关闭当前编辑框 Ctrl + 2,L：自动补全代码(使用方式是先按Ctrl+2，然后个1秒左右再按L键即可) Alt + Shift + R：重命名(需要对项目名、包名、类名、变量名、方法名等进行修改时，建议使用此快捷键，避免发生不必要的错误) Alt + Shift + Z：对异常进行捕获 Alt + Shift + S + C：生成实体类的无参构造方法 Alt + Shift + S + O：生成实体类的有参构造方法(可根据实际情况选择参数，一般是select All) Alt + Shift + S + R：生成实体类的Getters和Setters方法 Alt + Shift + S + S：生成实体类的toString()方法 Alt + Shift + S + H：生成实体类的hashCode()和equals()方法 以上为Eclipse在开发中一些常用的快捷键，下面介绍一些常见的设置 常见设置1.如何显示行号在代码的最左侧前面，点击鼠标右键，选择 –&gt; Show Line Numbers即可显示行号。(想取消显示行号就再次选择即可) 2.如何修改字体大小及字体风格a：修改Java代码区域的字体大小及风格：window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Java –&gt; Java Edit Text Font –&gt; editb：修改控制台( Console)的字体及风格window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Debug –&gt; Console font –&gt; editc：修改全部的字体及风格(包括Java代码和控制台)window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Basic –&gt; Text Font –&gt; edit 3.切换工作空间(Workspace)File –&gt; Switch Workspace –&gt; Other 4.导入Java项目File –&gt;Import –&gt; General –&gt; Existing Progects into Workspace 5.取消悬浮提示(将鼠标停留在某个类上所出现的提示信息)window –&gt; Preferences –&gt; Java –&gt; Editor –&gt; Hovers。右边将Combined Hover勾去掉(这样代码的悬浮框就不会自动出现了。如果想看提示，将光标悬浮在代码上，按F2即可) 6.断点调试(重要)首先何为断点调试呢？断点调试就是在某区域的代码中加上开始断点和结束断点，然后等开始执行断点调试就可以看到代码是如何一步一步地执行下去的。那么我们如何使用断点调试呢？ a：添加断点在执行代码区域的左边双击就可出现一个小蓝点作为开始断点，然后又在结束调试的代码左边双击出现一个小蓝点作为结束断点(注意不要在注释上面作断点) b：使用断点调试在Java代码区域点击鼠标右键 –&gt; Debug As –&gt; Java Application(这是可能会弹出一个对话框，询问是否打开调试界面，点击yes即可)调试界面如下： c：如何一步一步执行呢点击F6即可执行下一步(淡绿色的代码块就是下一步将要执行的代码) d：停止调试点击上图出现的红色的正方形即可停止调试 7.代码自动联想功能(边输入边提示)Window –&gt; Preferences –&gt; Java –&gt; Content Assist在Content Assist这个界面下面有一个Auto activation triggers for Java，在其后面的框中添加.abcdefghijklmnopqrstuvwxyz即可实现自动联想功能。 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hunterblog.cn/tags/Eclipse/"}]},{"title":"JavaSe之面向对象","date":"2017-02-24T14:26:33.000Z","path":"2017/02/24/JavaSe/","text":"注：此文主要讲述何为面向对象、面向对象的三大特征、抽象类和接口，但只作简单的阐述，不深入研究 何为面向对象俗话说万物皆对象，每一个事物都可看作为一个对象，对象就拥有它的属性和功能(也称行为)，比如说一名学生，他的属性就有姓名，年龄，学号，体重，身高……等，功能(行为)有学习，吃饭，睡觉……等。Java中将这些对象抽象为每一个类，然后再对这些类进行一些相应的操作。创建对象的格式是： 类名 对象名 = new 类名(); 面向对象的三大思想特征：封装，继承，多态1. 封装1.1 定义：指隐藏对象的属性和实现细节，仅对外提供公共的访问方式（换句话说就是将属性私有化，并提供共有的方法访问） 1.2 private关键字可用于修饰成员内容，包括成员变量和成员方法，被他修饰完毕后的内容，在其他类中是不能直接访问的，换句话说就是被private修饰的内容只能在本类中使用 1.3 getter/setter方法的使用因为类的属性被私有化，只能在本类中访问，其他类想要访问就需要提供getter方法和setter方法。但这两个方法时相互独立的，不一定必须出现（get方法和set方法的名字可以随便起，只不过大家通过方法访问私有属性的时候形成了一个默认的规则：设置类的属性值通过setXxx()方法，获取类的属性通过getXxx()方法）。 1.4 this关键字a.this关键字只能代表本类对象b.this关键字代表所属方法的所属对象c.谁调用this，this就代表谁d.this可用于区分成员变量和局部变量同名的情况（例如this.属性名代表的是成员变量） 1.5 构造方法1.5.1 特点：a.方法名必须和类名保持一致b.没有返回值类型并且没有具体的返回值，连void都没有 1.5.2 作用：给对象的属性进行初始化 1.5.3 注意事项a.如果没有明确给出构造方法，系统会默认给出一个无参的构造方法b.只要给出明确的构造方法，系统将不会提供任何的构造方法c.构造方法的重载体现在参数的不同（包括参数类型、个数以及顺序） 1.6 给私有属性赋值的方式a.通过set方法（推荐使用）b.通过构造方法c.在定义成员变量的时候就赋值例如：private String name = “张三”；d.通过反射中的Fied类中的对象给对象的属性赋值 1.7构造方法和setter方法的区别a.构造方法是在创建对象的时候赋值，只能赋值一次b.setter方法是在创建完对象以后再给对象的属性赋值，能赋值多次 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 一个类的代码分布图： 属性 构造方法 成员方法 get方法和set方法 */public class Student &#123; /** 姓名 */ private String name; /** 年龄 */ private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; /** * 获取姓名 * * @return name 姓名 */ public String getName() &#123; return name; &#125; /** * 设置姓名 * * @param name * 姓名 */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取年龄 * * @return age 年龄 */ public int getAge() &#123; return age; &#125; /** * 设置年龄 * * @param age * 年龄 */ public void setAge(int age) &#123; this.age = age; &#125;&#125;测试类public class Test &#123; public static void main(String[] args) &#123; //通过无参构造创建对象，并给成员变量赋值 Student zs = new Student(); zs.setName(\"张三\"); zs.setAge(13); //通过有参构造创建对象，并给成员变量赋值 Student ls = new Student(\"李四\",14); //调用对象的方法 System.out.println(zs.getName()+\"----\"+zs.getAge()); System.out.println(ls.getName()+\"----\"+ls.getAge()); &#125;&#125; 1.8 static关键字1.8.1 定义static意为静态，可以修饰成员变量和成员方法，被static修饰的成员，可以被该类下的所有对象共享（例如 private static int number = 10; 这个number变量就可以被该类下所有对象使用） 1.8.2特点a.被static修饰的成员随着类的加载而加载， 并且优先于对象而存在（即在内存中加载完该成员才到对象的创建）b.可以通过类名.直接调用c.被该类下所有对象共享 1.8.3注意事项a.在静态方法中没有this关键字，因为静态是随着类的加载而加载，而this关键字是对象创建才存在的b.静态方法只能访问静态成员变量和静态的方法（即静态只能访问静态）c.静态内容可以通过创建对象调用，也可以直接通过类名.调用。（推荐通过类名点调用） 2.继承2.1由来和定义a.在多个类中存在相同的属性和行为时，将这些内容抽取到单个类中，那么多个类无需再定义该属性和行为，只需要继承那单个类即可b.多个类成为子类或派生类，单个类成为超类或者父类又或者基类 2.2好处和弊端a.提高代码的复用性b.使类与类产生关系，是多态的前提c.Java中只支持单继承，不支持多继承，但支持多层继承 2.3使用场景子类是父类的一种，比如猫继承动物，猫就是子类，动物就是父类（注意：不要为了获取某个功能而去继承） 2.4this和super比较2.4.1概念上的区别super代表的是父类内存空间标识this代表所在方法所属对象的引用 2.4.2super使用场景a.当子父类中出现同名成员可以用super区分b.子类调用父类的构造方法可以用super.方法名调用 2.4.3注意事项a.构造方法中的this()和super()语句必须放在第一行，并且只能取其一b.如果父类中无无参构造，子类只能通过super(参数)调用父类的构造方法，通过this(…)调用本类的构造方法 2.5重写OverRide和重载OverLoad2.5.1重写OverRide在子父类关系中，子类中存在与父类中方法声明完全一样的方法叫重写（即除了方法体不一样，其他都是一样的，但子类的权限要大于等于父类的） 2.5.2重载OverLoad在一个类中或者在子父类中存在多个同名方法，并且参数列表不同的方法叫重载 2.5.3注意事项a.只有方法才存在重写，变量不存在重写这一说法b.父类中的私有方法不能被覆盖 2.6final关键字2.6.1定义很多时候有些方法内容时不能被重写的。而我们知道父类方法声明为public就可以被重写。针对这种情况，我们可以做个标记，告诉别人此类不能被重写final ：最终的意思，可以修饰类，变量以及成员方法 2.6.2被final修饰的特点a.被final修饰的方法不能被重写b.被final修饰的类不能被继承c.被final修饰的变量其实就是常量，必须显示地赋值，并且命名要全部大写，每个单词之间用下划线连接起来 2.6.3被final修饰的类java.lang.reflect.Array boolean的包装类java.lang.Boolean byte的包装类java.lang.Byte char的包装类java.lang.Character double的包装类java.lang.Double float的包装类java.lang.Float int的包装类java.lang.Integer long的包装类java.lang.Long short的包装类java.lang.Short void的包装类java.lang.Void String类java.lang.String System类java.lang.System Class类java.lang.Class&lt;T&gt; 编译器java.lang.Compiler类 Math类java.lang.Math 两个可变字符序列类java.lang.StringBuffer与java.lang.StringBuilder Scanner类java.util.Scanner 正则匹配器java.util.regex.Matcher 正则表达式编译形式类java.util.regex.Pattern 3.多态3.1多态的定义对象在不同时刻表现出来的不同状态 3.2多态的前提条件a.要有继承关系或者实现关系b.要有方法重写或者实现关系c.要有父类引用指向子类对象或者父类接口指向子类对象 3.3多态的成员特点3.3.1成员变量编译看等号左边，运行看等号左边12Fu fu = new Zi();System.out.println(fu.name);//调用的是父类的name属性 3.3.2成员方法编译看等号的左边，运行看等号的右边12Fu fu = new Zi();fu.show();//调用的是子类的show() 小结：方法运行看右边 3.4多态的好处和弊端3.4.1弊端父类引用不能直接使用子类对象的特有功能，只能通过向下转型（强转）实现 3.4.2好处增强了程序的拓展性和可维护性，大大减少了维护成本 拓展抽象类1.由来类里面封装的是相关的属性和行为，但是有些行为我们是不确定做什么的，这个时候我们就把这个方法用abstract修饰，当方法被这个关键字修饰以后，就不能有方法体了，并且这个类也必须被abstract修饰，这就是抽象类的由来 2.定义如果一个类中含有抽象方法，这个类就可以被称为抽象类，该类也需要被abstract修饰。它的作用是强制要求子类必须实现某些功能（抽象方法：只有方法声明，没有方法体，被abstract修饰） 3.格式123456789101112131415161718//定义抽象类的格式 abstract class Animal&#123; abstract void eat(); public void run()&#123; System.out.println(\"我在跑步\"); &#125; &#125; //使用格式1 //定义个普通类，继承抽象类，必须实现抽象类中的抽象方法 class Dog extends Animal&#123; void eat()&#123; System.out.println(\"狗吃骨头\"); &#125; &#125; //使用格式2 //定义一个抽象类继承抽象类，不是必须要实现父类的抽象方法 abstract class Cat extends Animal&#123; &#125; 4.基本特点a. 抽象方法和抽象类用关键字abstract表示。b. 有抽象方法的类一定是抽象类(或者接口)。抽象类中不一定有抽象方法。c. 抽象类不能被实例化。d. 如果一个类继承抽象类，那么这个类要么本身也是抽象类。这个类 必须重写父类的所有抽象方法。 5.成员特点5.1 成员变量可以有成员变量，也可以有常量 5.2 构造方法抽象类有构造方法，但是不能通过构造方法创建对象，构造方法的作用是让子类访问父类数据之前，对父类数据进行初始化 5.3成员方法可以有抽象方法，也可以有非抽象方法抽象方法是为了要求子类做某些事情非抽象方法是为了提高代码的复用性，被子类继承 6.使用场景 人刚生下来就具备哭的行为特征，但是每个人哭的行为不一样，所以人应该定义为抽象类，这些与生俱来的属性和行为应该定义在类里面 接口1.定义我们可以把接口看成是一种特殊的抽象类。比抽象类更抽象。因为它里面的方法都是抽象的。但是注意，接口不是类，我们只是把他看成类 2.格式1234567891011121314151617//定义格式 interface 接口名 &#123; //静态常量和抽象方法 &#125; //使用格式 //一个类实现一个接口 class 类名 implements 接口名1，接口名2... &#123; //覆盖接口中的全部方法 &#125; //一个抽象类实现一个接口，不必重写接口中的抽象方法 abstract class 类名 extends Object implements 接口1, 接口2,接口..... &#123; //方法体不需要全部都覆盖 &#125; //一个接口继承一个接口 interface 接口名 extends 接口1，接口2.. &#123; &#125; 3.基本特点a. 接口不能被实例化b. 接口中的方法要么被子类重写，要么子类也是抽象类 4.成员特点4.1 成员变量接口中只有常量。因为接口中的成员变量有默认的修饰符：public static final 4.2构造方法接口没有构造方法。因为接口中的成员变量都被final修饰，定义的时候必须做初始化 4.3成员方法接口中的方法都是抽象方法，没有方法体。因为接口中的成员方法有默认修饰符public abstract 5.思想特点a. 接口是对外暴露的规则b. 接口是程序的功能拓展c. 接口的出现降低耦合性d. 接口可以用来多实现 6.使用场景随着人的年纪的增加，会学习舞蹈，吉他，这些都是后天培养的拓展的功能，所以应该把学习跳舞和学习吉他定义为接口，这些后天学习的拓展功能应该定义在接口里 抽象类和接口相同点：都是不断向上抽取而来不同点：a.抽象类需要被继承，而且只能单继承 接口需要被实现，而且可以多实现 b.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法 接口中只能定义抽象方法，必须有子类实现 c.抽象类的字段默认是friendly 接口的字段默认是public static final 下面是抽象类与接口的具体使用： 类、抽象类与接口三者之间的继承与实现关系： 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"http://hunterblog.cn/tags/JavaSe/"}]}]