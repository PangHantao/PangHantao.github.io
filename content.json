[{"title":"测试","date":"2017-02-24T14:38:03.000Z","path":"2017/02/24/java/","text":"测试测试测试测试测试测试 测试测试测试测试测试测试","tags":[{"name":"Test","slug":"Test","permalink":"http://hunterblog.cn/tags/Test/"}]},{"title":"JavaSe之面向对象","date":"2017-02-24T14:26:33.000Z","path":"2017/02/24/JavaSe/","text":"版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。 此文主要讲述何为面向对象、面向对象的三大特征、抽象类和接口，但只作简单的阐述，不深入研究 何为面向对象俗话说万物皆对象，每一个事物都可看作为一个对象，对象就拥有它的属性和功能(也称行为)，比如说一名学生，他的属性就有姓名，年龄，学号，体重，身高……等，功能(行为)有学习，吃饭，睡觉……等。Java中将这些对象抽象为每一个类，然后再对这些类进行一些相应的操作。创建对象的格式是： 类名 对象名 = new 类名(); 面向对象的三大思想特征：封装，继承，多态1. 封装1.1 定义：指隐藏对象的属性和实现细节，仅对外提供公共的访问方式（换句话说就是将属性私有化，并提供共有的方法访问） 1.2 private关键字可用于修饰成员内容，包括成员变量和成员方法，被他修饰完毕后的内容，在其他类中是不能直接访问的，换句话说就是被private修饰的内容只能在本类中使用 1.3 getter/setter方法的使用因为类的属性被私有化，只能在本类中访问，其他类想要访问就需要提供getter方法和setter方法。但这两个方法时相互独立的，不一定必须出现（get方法和set方法的名字可以随便起，只不过大家通过方法访问私有属性的时候形成了一个默认的规则：设置类的属性值通过setXxx()方法，获取类的属性通过getXxx()方法）。 1.4 this关键字a.this关键字只能代表本类对象b.this关键字代表所属方法的所属对象c.谁调用this，this就代表谁d.this可用于区分成员变量和局部变量同名的情况（例如this.属性名代表的是成员变量） 1.5 构造方法1.5.1 特点：a.方法名必须和类名保持一致b.没有返回值类型并且没有具体的返回值，连void都没有 1.5.2 作用：给对象的属性进行初始化 1.5.3 注意事项a.如果没有明确给出构造方法，系统会默认给出一个无参的构造方法b.只要给出明确的构造方法，系统将不会提供任何的构造方法c.构造方法的重载体现在参数的不同（包括参数类型、个数以及顺序） 1.6 给私有属性赋值的方式a.通过set方法（推荐使用）b.通过构造方法c.在定义成员变量的时候就赋值例如：private String name = “张三”；d.通过反射中的Fied类中的对象给对象的属性赋值 1.7构造方法和setter方法的区别a.构造方法是在创建对象的时候赋值，只能赋值一次b.setter方法是在创建完对象以后再给对象的属性赋值，能赋值多次 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 一个类的代码分布图： 属性 构造方法 成员方法 get方法和set方法 */public class Student &#123; /** 姓名 */ private String name; /** 年龄 */ private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; /** * 获取姓名 * * @return name 姓名 */ public String getName() &#123; return name; &#125; /** * 设置姓名 * * @param name * 姓名 */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取年龄 * * @return age 年龄 */ public int getAge() &#123; return age; &#125; /** * 设置年龄 * * @param age * 年龄 */ public void setAge(int age) &#123; this.age = age; &#125;&#125;测试类public class Test &#123; public static void main(String[] args) &#123; //通过无参构造创建对象，并给成员变量赋值 Student zs = new Student(); zs.setName(\"张三\"); zs.setAge(13); //通过有参构造创建对象，并给成员变量赋值 Student ls = new Student(\"李四\",14); //调用对象的方法 System.out.println(zs.getName()+\"----\"+zs.getAge()); System.out.println(ls.getName()+\"----\"+ls.getAge()); &#125;&#125; 1.8 static关键字1.8.1 定义static意为静态，可以修饰成员变量和成员方法，被static修饰的成员，可以被该类下的所有对象共享（例如 private static int number = 10; 这个number变量就可以被该类下所有对象使用） 1.8.2特点a.被static修饰的成员随着类的加载而加载， 并且优先于对象而存在（即在内存中加载完该成员才到对象的创建）b.可以通过类名.直接调用c.被该类下所有对象共享 1.8.3注意事项a.在静态方法中没有this关键字，因为静态是随着类的加载而加载，而this关键字是对象创建才存在的b.静态方法只能访问静态成员变量和静态的方法（即静态只能访问静态）c.静态内容可以通过创建对象调用，也可以直接通过类名.调用。（推荐通过类名点调用） 2.继承2.1由来和定义a.在多个类中存在相同的属性和行为时，将这些内容抽取到单个类中，那么多个类无需再定义该属性和行为，只需要继承那单个类即可b.多个类成为子类或派生类，单个类成为超类或者父类又或者基类 2.2好处和弊端a.提高代码的复用性b.使类与类产生关系，是多态的前提c.Java中只支持单继承，不支持多继承，但支持多层继承 2.3使用场景子类是父类的一种，比如猫继承动物，猫就是子类，动物就是父类（注意：不要为了获取某个功能而去继承） 2.4this和super比较2.4.1概念上的区别super代表的是父类内存空间标识this代表所在方法所属对象的引用 2.4.2super使用场景a.当子父类中出现同名成员可以用super区分b.子类调用父类的构造方法可以用super.方法名调用 2.4.3注意事项a.构造方法中的this()和super()语句必须放在第一行，并且只能取其一b.如果父类中无无参构造，子类只能通过super(参数)调用父类的构造方法，通过this(…)调用本类的构造方法 2.5重写OverRide和重载OverLoad2.5.1重写OverRide在子父类关系中，子类中存在与父类中方法声明完全一样的方法叫重写（即除了方法体不一样，其他都是一样的，但子类的权限要大于等于父类的） 2.5.2重载OverLoad在一个类中或者在子父类中存在多个同名方法，并且参数列表不同的方法叫重载 2.5.3注意事项a.只有方法才存在重写，变量不存在重写这一说法b.父类中的私有方法不能被覆盖 2.6final关键字2.6.1定义很多时候有些方法内容时不能被重写的。而我们知道父类方法声明为public就可以被重写。针对这种情况，我们可以做个标记，告诉别人此类不能被重写final ：最终的意思，可以修饰类，变量以及成员方法 2.6.2被final修饰的特点a.被final修饰的方法不能被重写b.被final修饰的类不能被继承c.被final修饰的变量其实就是常量，必须显示地赋值，并且命名要全部大写，每个单词之间用下划线连接起来 2.6.3被final修饰的类java.lang.reflect.Array boolean的包装类java.lang.Boolean byte的包装类java.lang.Byte char的包装类java.lang.Character double的包装类java.lang.Double float的包装类java.lang.Float int的包装类java.lang.Integer long的包装类java.lang.Long short的包装类java.lang.Short void的包装类java.lang.Void String类java.lang.String System类java.lang.System Class类java.lang.Class&lt;T&gt; 编译器java.lang.Compiler类 Math类java.lang.Math 两个可变字符序列类java.lang.StringBuffer与java.lang.StringBuilder Scanner类java.util.Scanner 正则匹配器java.util.regex.Matcher 正则表达式编译形式类java.util.regex.Pattern 3.多态3.1多态的定义对象在不同时刻表现出来的不同状态 3.2多态的前提条件a.要有继承关系或者实现关系b.要有方法重写或者实现关系c.要有父类引用指向子类对象或者父类接口指向子类对象 3.3多态的成员特点3.3.1成员变量编译看等号左边，运行看等号左边12Fu fu = new Zi();System.out.println(fu.name);//调用的是父类的name属性 3.3.2成员方法编译看等号的左边，运行看等号的右边12Fu fu = new Zi();fu.show();//调用的是子类的show() 小结：方法运行看右边 3.4多态的好处和弊端3.4.1弊端父类引用不能直接使用子类对象的特有功能，只能通过向下转型（强转）实现 3.4.2好处增强了程序的拓展性和可维护性，大大减少了维护成本 拓展抽象类1.由来类里面封装的是相关的属性和行为，但是有些行为我们是不确定做什么的，这个时候我们就把这个方法用abstract修饰，当方法被这个关键字修饰以后，就不能有方法体了，并且这个类也必须被abstract修饰，这就是抽象类的由来 2.定义如果一个类中含有抽象方法，这个类就可以被称为抽象类，该类也需要被abstract修饰。它的作用是强制要求子类必须实现某些功能（抽象方法：只有方法声明，没有方法体，被abstract修饰） 3.格式123456789101112131415161718//定义抽象类的格式 abstract class Animal&#123; abstract void eat(); public void run()&#123; System.out.println(\"我在跑步\"); &#125; &#125; //使用格式1 //定义个普通类，继承抽象类，必须实现抽象类中的抽象方法 class Dog extends Animal&#123; void eat()&#123; System.out.println(\"狗吃骨头\"); &#125; &#125; //使用格式2 //定义一个抽象类继承抽象类，不是必须要实现父类的抽象方法 abstract class Cat extends Animal&#123; &#125; 4.基本特点a. 抽象方法和抽象类用关键字abstract表示。b. 有抽象方法的类一定是抽象类(或者接口)。抽象类中不一定有抽象方法。c. 抽象类不能被实例化。d. 如果一个类继承抽象类，那么这个类要么本身也是抽象类。这个类 必须重写父类的所有抽象方法。 5.成员特点5.1 成员变量可以有成员变量，也可以有常量 5.2 构造方法抽象类有构造方法，但是不能通过构造方法创建对象，构造方法的作用是让子类访问父类数据之前，对父类数据进行初始化 5.3成员方法可以有抽象方法，也可以有非抽象方法抽象方法是为了要求子类做某些事情非抽象方法是为了提高代码的复用性，被子类继承 6.使用场景 人刚生下来就具备哭的行为特征，但是每个人哭的行为不一样，所以人应该定义为抽象类，这些与生俱来的属性和行为应该定义在类里面 接口1.定义我们可以把接口看成是一种特殊的抽象类。比抽象类更抽象。因为它里面的方法都是抽象的。但是注意，接口不是类，我们只是把他看成类 2.格式1234567891011121314151617//定义格式 interface 接口名 &#123; //静态常量和抽象方法 &#125; //使用格式 //一个类实现一个接口 class 类名 implements 接口名1，接口名2... &#123; //覆盖接口中的全部方法 &#125; //一个抽象类实现一个接口，不必重写接口中的抽象方法 abstract class 类名 extends Object implements 接口1, 接口2,接口..... &#123; //方法体不需要全部都覆盖 &#125; //一个接口继承一个接口 interface 接口名 extends 接口1，接口2.. &#123; &#125; 3.基本特点a. 接口不能被实例化b. 接口中的方法要么被子类重写，要么子类也是抽象类 4.成员特点4.1 成员变量接口中只有常量。因为接口中的成员变量有默认的修饰符：public static final 4.2构造方法接口没有构造方法。因为接口中的成员变量都被final修饰，定义的时候必须做初始化 4.3成员方法接口中的方法都是抽象方法，没有方法体。因为接口中的成员方法有默认修饰符public abstract 5.思想特点a. 接口是对外暴露的规则b. 接口是程序的功能拓展c. 接口的出现降低耦合性d. 接口可以用来多实现 6.使用场景随着人的年纪的增加，会学习舞蹈，吉他，这些都是后天培养的拓展的功能，所以应该把学习跳舞和学习吉他定义为接口，这些后天学习的拓展功能应该定义在接口里","tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"http://hunterblog.cn/tags/JavaSe/"}]}]