[{"title":"Eclipse常用快捷键以及常见设置","date":"2017-02-27T11:44:32.000Z","path":"2017/02/27/EclipseForUse/","text":"Eclipse作为一个常用的开发工具，其功能也比较强大，要想在Eclipse中快速高效地进行开发，使用快捷键能使我们在开发中达到事半功倍的效果，下面将介绍关于Eclipse的一些常用的快捷键以及一些常见设置，希望能帮助到各位Coder。 常用快捷键：Alt + /：内容补全键，功能很强悍，当不记得全类名、方法名或属性名时使用这个即可提示，也是最常用的一个快捷键。(有一个设置能够替代内容补全键，能边输入边联想，下面设置中将介绍到) Ctrl + /：添加或取消单行注释 Ctrl + Shift + /：选中多行，即可添加多行注释 Ctrl + Shift + /：在多行注释的区域内，可取消多行注释 Ctrl + Shift + ↑或↓：快速复制所选中的代码(注意：此快捷键可能和Windows中的屏幕反转功能冲突，禁用Windows屏幕反转功能才可使用) Alt + ↑或↓：向上或向下移动所选择的代码 Ctrl + Shift + F：格式化代码(当代码写的很乱时，这个快捷键可以将代码的按照标准得格式显示) Ctrl + Shift + O：快速导入包 Alt + Shift + M：将选中的代码抽取成为一个方法 Ctrl + F：查找 Ctrl + D：删除选中行 Ctrl + 1 ：快速修复(最常用的快捷键之一。当代码下方出现小红线时，此快捷键可以提示多种情况进行修复，根据具体情况选择) Ctrl + W关闭当前编辑框 Ctrl + 2,L：自动补全代码(使用方式是先按Ctrl+2，然后个1秒左右再按L键即可) Alt + Shift + R：重命名(需要对项目名、包名、类名、变量名、方法名等进行修改时，建议使用此快捷键，避免发生不必要的错误) Alt + Shift + Z：对异常进行捕获 Alt + Shift + S + C：生成实体类的无参构造方法 Alt + Shift + S + O：生成实体类的有参构造方法(可根据实际情况选择参数，一般是select All) Alt + Shift + S + R：生成实体类的Getters和Setters方法 Alt + Shift + S + S：生成实体类的toString()方法 Alt + Shift + S + H：生成实体类的hashCode()和equals()方法 以上为Eclipse在开发中一些常用的快捷键，下面介绍一些常见的设置 常见设置1.如何显示行号在代码的最左侧前面，点击鼠标右键，选择 –&gt; Show Line Numbers即可显示行号。(想取消显示行号就再次选择即可) 2.如何修改字体大小及字体风格a：修改Java代码区域的字体大小及风格：window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Java –&gt; Java Edit Text Font –&gt; editb：修改控制台( Console)的字体及风格window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Debug –&gt; Console font –&gt; editc：修改全部的字体及风格(包括Java代码和控制台)window –&gt; Preferences –&gt; General –&gt; Appearance –&gt; Colors And Fonts –&gt; Basic –&gt; Text Font –&gt; edit 3.切换工作空间(Workspace)File –&gt; Switch Workspace –&gt; Other 4.导入Java项目File –&gt;Import –&gt; General –&gt; Existing Progects into Workspace 5.取消悬浮提示(将鼠标停留在某个类上所出现的提示信息)window –&gt; Preferences –&gt; Java –&gt; Editor –&gt; Hovers。右边将Combined Hover勾去掉(这样代码的悬浮框就不会自动出现了。如果想看提示，将光标悬浮在代码上，按F2即可) 6.断点调试(重要)首先何为断点调试呢？断点调试就是在某区域的代码中加上开始断点和结束断点，然后等开始执行断点调试就可以看到代码是如何一步一步地执行下去的。那么我们如何使用断点调试呢？ a：添加断点在执行代码区域的左边双击就可出现一个小蓝点作为开始断点，然后又在结束调试的代码左边双击出现一个小蓝点作为结束断点(注意不要在注释上面作断点) b：使用断点调试在Java代码区域点击鼠标右键 –&gt; Debug As –&gt; Java Application(这是可能会弹出一个对话框，询问是否打开调试界面，点击yes即可)调试界面如下： c：如何一步一步执行呢点击F6即可执行下一步(淡绿色的代码块就是下一步将要执行的代码) d：停止调试点击上图出现的红色的正方形即可停止调试 7.代码自动联想功能(边输入边提示)Window –&gt; Preferences –&gt; Java –&gt; Content Assist在Content Assist这个界面下面有一个Auto activation triggers for Java，在其后面的框中添加.abcdefghijklmnopqrstuvwxyz即可实现自动联想功能。 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://hunterblog.cn/tags/Eclipse/"}]},{"title":"JavaSe之面向对象","date":"2017-02-24T14:26:33.000Z","path":"2017/02/24/JavaSe/","text":"注：此文主要讲述何为面向对象、面向对象的三大特征、抽象类和接口，但只作简单的阐述，不深入研究 何为面向对象俗话说万物皆对象，每一个事物都可看作为一个对象，对象就拥有它的属性和功能(也称行为)，比如说一名学生，他的属性就有姓名，年龄，学号，体重，身高……等，功能(行为)有学习，吃饭，睡觉……等。Java中将这些对象抽象为每一个类，然后再对这些类进行一些相应的操作。创建对象的格式是： 类名 对象名 = new 类名(); 面向对象的三大思想特征：封装，继承，多态1. 封装1.1 定义：指隐藏对象的属性和实现细节，仅对外提供公共的访问方式（换句话说就是将属性私有化，并提供共有的方法访问） 1.2 private关键字可用于修饰成员内容，包括成员变量和成员方法，被他修饰完毕后的内容，在其他类中是不能直接访问的，换句话说就是被private修饰的内容只能在本类中使用 1.3 getter/setter方法的使用因为类的属性被私有化，只能在本类中访问，其他类想要访问就需要提供getter方法和setter方法。但这两个方法时相互独立的，不一定必须出现（get方法和set方法的名字可以随便起，只不过大家通过方法访问私有属性的时候形成了一个默认的规则：设置类的属性值通过setXxx()方法，获取类的属性通过getXxx()方法）。 1.4 this关键字a.this关键字只能代表本类对象b.this关键字代表所属方法的所属对象c.谁调用this，this就代表谁d.this可用于区分成员变量和局部变量同名的情况（例如this.属性名代表的是成员变量） 1.5 构造方法1.5.1 特点：a.方法名必须和类名保持一致b.没有返回值类型并且没有具体的返回值，连void都没有 1.5.2 作用：给对象的属性进行初始化 1.5.3 注意事项a.如果没有明确给出构造方法，系统会默认给出一个无参的构造方法b.只要给出明确的构造方法，系统将不会提供任何的构造方法c.构造方法的重载体现在参数的不同（包括参数类型、个数以及顺序） 1.6 给私有属性赋值的方式a.通过set方法（推荐使用）b.通过构造方法c.在定义成员变量的时候就赋值例如：private String name = “张三”；d.通过反射中的Fied类中的对象给对象的属性赋值 1.7构造方法和setter方法的区别a.构造方法是在创建对象的时候赋值，只能赋值一次b.setter方法是在创建完对象以后再给对象的属性赋值，能赋值多次 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 一个类的代码分布图： 属性 构造方法 成员方法 get方法和set方法 */public class Student &#123; /** 姓名 */ private String name; /** 年龄 */ private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; /** * 获取姓名 * * @return name 姓名 */ public String getName() &#123; return name; &#125; /** * 设置姓名 * * @param name * 姓名 */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取年龄 * * @return age 年龄 */ public int getAge() &#123; return age; &#125; /** * 设置年龄 * * @param age * 年龄 */ public void setAge(int age) &#123; this.age = age; &#125;&#125;测试类public class Test &#123; public static void main(String[] args) &#123; //通过无参构造创建对象，并给成员变量赋值 Student zs = new Student(); zs.setName(\"张三\"); zs.setAge(13); //通过有参构造创建对象，并给成员变量赋值 Student ls = new Student(\"李四\",14); //调用对象的方法 System.out.println(zs.getName()+\"----\"+zs.getAge()); System.out.println(ls.getName()+\"----\"+ls.getAge()); &#125;&#125; 1.8 static关键字1.8.1 定义static意为静态，可以修饰成员变量和成员方法，被static修饰的成员，可以被该类下的所有对象共享（例如 private static int number = 10; 这个number变量就可以被该类下所有对象使用） 1.8.2特点a.被static修饰的成员随着类的加载而加载， 并且优先于对象而存在（即在内存中加载完该成员才到对象的创建）b.可以通过类名.直接调用c.被该类下所有对象共享 1.8.3注意事项a.在静态方法中没有this关键字，因为静态是随着类的加载而加载，而this关键字是对象创建才存在的b.静态方法只能访问静态成员变量和静态的方法（即静态只能访问静态）c.静态内容可以通过创建对象调用，也可以直接通过类名.调用。（推荐通过类名点调用） 2.继承2.1由来和定义a.在多个类中存在相同的属性和行为时，将这些内容抽取到单个类中，那么多个类无需再定义该属性和行为，只需要继承那单个类即可b.多个类成为子类或派生类，单个类成为超类或者父类又或者基类 2.2好处和弊端a.提高代码的复用性b.使类与类产生关系，是多态的前提c.Java中只支持单继承，不支持多继承，但支持多层继承 2.3使用场景子类是父类的一种，比如猫继承动物，猫就是子类，动物就是父类（注意：不要为了获取某个功能而去继承） 2.4this和super比较2.4.1概念上的区别super代表的是父类内存空间标识this代表所在方法所属对象的引用 2.4.2super使用场景a.当子父类中出现同名成员可以用super区分b.子类调用父类的构造方法可以用super.方法名调用 2.4.3注意事项a.构造方法中的this()和super()语句必须放在第一行，并且只能取其一b.如果父类中无无参构造，子类只能通过super(参数)调用父类的构造方法，通过this(…)调用本类的构造方法 2.5重写OverRide和重载OverLoad2.5.1重写OverRide在子父类关系中，子类中存在与父类中方法声明完全一样的方法叫重写（即除了方法体不一样，其他都是一样的，但子类的权限要大于等于父类的） 2.5.2重载OverLoad在一个类中或者在子父类中存在多个同名方法，并且参数列表不同的方法叫重载 2.5.3注意事项a.只有方法才存在重写，变量不存在重写这一说法b.父类中的私有方法不能被覆盖 2.6final关键字2.6.1定义很多时候有些方法内容时不能被重写的。而我们知道父类方法声明为public就可以被重写。针对这种情况，我们可以做个标记，告诉别人此类不能被重写final ：最终的意思，可以修饰类，变量以及成员方法 2.6.2被final修饰的特点a.被final修饰的方法不能被重写b.被final修饰的类不能被继承c.被final修饰的变量其实就是常量，必须显示地赋值，并且命名要全部大写，每个单词之间用下划线连接起来 2.6.3被final修饰的类java.lang.reflect.Array boolean的包装类java.lang.Boolean byte的包装类java.lang.Byte char的包装类java.lang.Character double的包装类java.lang.Double float的包装类java.lang.Float int的包装类java.lang.Integer long的包装类java.lang.Long short的包装类java.lang.Short void的包装类java.lang.Void String类java.lang.String System类java.lang.System Class类java.lang.Class&lt;T&gt; 编译器java.lang.Compiler类 Math类java.lang.Math 两个可变字符序列类java.lang.StringBuffer与java.lang.StringBuilder Scanner类java.util.Scanner 正则匹配器java.util.regex.Matcher 正则表达式编译形式类java.util.regex.Pattern 3.多态3.1多态的定义对象在不同时刻表现出来的不同状态 3.2多态的前提条件a.要有继承关系或者实现关系b.要有方法重写或者实现关系c.要有父类引用指向子类对象或者父类接口指向子类对象 3.3多态的成员特点3.3.1成员变量编译看等号左边，运行看等号左边12Fu fu = new Zi();System.out.println(fu.name);//调用的是父类的name属性 3.3.2成员方法编译看等号的左边，运行看等号的右边12Fu fu = new Zi();fu.show();//调用的是子类的show() 小结：方法运行看右边 3.4多态的好处和弊端3.4.1弊端父类引用不能直接使用子类对象的特有功能，只能通过向下转型（强转）实现 3.4.2好处增强了程序的拓展性和可维护性，大大减少了维护成本 拓展抽象类1.由来类里面封装的是相关的属性和行为，但是有些行为我们是不确定做什么的，这个时候我们就把这个方法用abstract修饰，当方法被这个关键字修饰以后，就不能有方法体了，并且这个类也必须被abstract修饰，这就是抽象类的由来 2.定义如果一个类中含有抽象方法，这个类就可以被称为抽象类，该类也需要被abstract修饰。它的作用是强制要求子类必须实现某些功能（抽象方法：只有方法声明，没有方法体，被abstract修饰） 3.格式123456789101112131415161718//定义抽象类的格式 abstract class Animal&#123; abstract void eat(); public void run()&#123; System.out.println(\"我在跑步\"); &#125; &#125; //使用格式1 //定义个普通类，继承抽象类，必须实现抽象类中的抽象方法 class Dog extends Animal&#123; void eat()&#123; System.out.println(\"狗吃骨头\"); &#125; &#125; //使用格式2 //定义一个抽象类继承抽象类，不是必须要实现父类的抽象方法 abstract class Cat extends Animal&#123; &#125; 4.基本特点a. 抽象方法和抽象类用关键字abstract表示。b. 有抽象方法的类一定是抽象类(或者接口)。抽象类中不一定有抽象方法。c. 抽象类不能被实例化。d. 如果一个类继承抽象类，那么这个类要么本身也是抽象类。这个类 必须重写父类的所有抽象方法。 5.成员特点5.1 成员变量可以有成员变量，也可以有常量 5.2 构造方法抽象类有构造方法，但是不能通过构造方法创建对象，构造方法的作用是让子类访问父类数据之前，对父类数据进行初始化 5.3成员方法可以有抽象方法，也可以有非抽象方法抽象方法是为了要求子类做某些事情非抽象方法是为了提高代码的复用性，被子类继承 6.使用场景 人刚生下来就具备哭的行为特征，但是每个人哭的行为不一样，所以人应该定义为抽象类，这些与生俱来的属性和行为应该定义在类里面 接口1.定义我们可以把接口看成是一种特殊的抽象类。比抽象类更抽象。因为它里面的方法都是抽象的。但是注意，接口不是类，我们只是把他看成类 2.格式1234567891011121314151617//定义格式 interface 接口名 &#123; //静态常量和抽象方法 &#125; //使用格式 //一个类实现一个接口 class 类名 implements 接口名1，接口名2... &#123; //覆盖接口中的全部方法 &#125; //一个抽象类实现一个接口，不必重写接口中的抽象方法 abstract class 类名 extends Object implements 接口1, 接口2,接口..... &#123; //方法体不需要全部都覆盖 &#125; //一个接口继承一个接口 interface 接口名 extends 接口1，接口2.. &#123; &#125; 3.基本特点a. 接口不能被实例化b. 接口中的方法要么被子类重写，要么子类也是抽象类 4.成员特点4.1 成员变量接口中只有常量。因为接口中的成员变量有默认的修饰符：public static final 4.2构造方法接口没有构造方法。因为接口中的成员变量都被final修饰，定义的时候必须做初始化 4.3成员方法接口中的方法都是抽象方法，没有方法体。因为接口中的成员方法有默认修饰符public abstract 5.思想特点a. 接口是对外暴露的规则b. 接口是程序的功能拓展c. 接口的出现降低耦合性d. 接口可以用来多实现 6.使用场景随着人的年纪的增加，会学习舞蹈，吉他，这些都是后天培养的拓展的功能，所以应该把学习跳舞和学习吉他定义为接口，这些后天学习的拓展功能应该定义在接口里 抽象类和接口相同点：都是不断向上抽取而来不同点：a.抽象类需要被继承，而且只能单继承 接口需要被实现，而且可以多实现 b.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法 接口中只能定义抽象方法，必须有子类实现 c.抽象类的字段默认是friendly 接口的字段默认是public static final 下面是抽象类与接口的具体使用： 类、抽象类与接口三者之间的继承与实现关系： 版权声明：本文为博主原创文章，转载请注明出处http://hunterblog.cn/ 和作者：Hunter，谢谢支持。","tags":[{"name":"JavaSe","slug":"JavaSe","permalink":"http://hunterblog.cn/tags/JavaSe/"}]}]